#Author: Sarah P. Flanagan (spflanagan.phd@gmail.com)

#' Plot courter frequencies for all of the reps
#' @param pattern The pattern for the filenames containing the reps whose courter freqs you want to plot
#' @param cols A vector of colors to use - must contain one named "courter"
#' @param x.lim optional specification of x-axis minimum and maximum (default = c(0,12000))
#' @return A list of data.frames containing the summary frequencies from all generations. The length of the list = number of files matching pattern.
#' @export
plot.courter.reps<-function(pattern,path="./",cols,x.lim=c(0,12000),make.plot=TRUE){
  courter.files<-list.files(pattern=pattern,path=path,full.names = TRUE)
  #set up colors
  mycols <- colorRampPalette(c("grey",cols["courter"],"black"))(length(courter.files)+1)[2:(1+length(courter.files))]
  #set up an empty plot
  if(isTRUE(make.plot)){
    plot(0:1,0:1,bty="L",xlab="Generations",ylab="Frequency of Courting Males",
       type='n',xlim=x.lim,ylim=c(0,1))
  }
  #plot each run's output and save it
  s<-lapply(courter.files,function(file){
    if(length(grep("gz$",file)>0)){
      summ<-suppressWarnings(read.delim(gzfile(file)))
    }else{
      summ<-suppressWarnings(read.delim(file))
    }
    sp<-by(summ,summ$Pop,function(pop){ #break it into each population in the file
      pop<-pop[,which(!colnames(pop)%in%grep("Marker",colnames(pop),value = TRUE))] #only keep the frequency data
      pop<-pop[!is.na(pop$CourterFreq),]
      n<-as.numeric(gsub("\\w+.*_(\\d+)_\\w+.*","\\1",file))
      if(isTRUE(make.plot)){
        points(pop$Generation,pop$CourterFreq,col=alpha(mycols[n],0.5),
             lwd=2,type="l")
      }
      return(pop)
    })
    names(sp)<-paste(file,1:length(sp),sep="_")
    return(as.list(sp))
  })
  if(isTRUE(make.plot)){
    text(x=10000,y=1.1,xpd=TRUE,"End of initial\ngenerations")
    clip(x1 = 0,x2=12000,y1=-0.1,y2=1.04)
    abline(v=10000,lty=2,lwd=2)
  }
  s<-do.call(c,s) #flatten out the list of lists
  return(s)
}

#' Create a table of courter frequencies in the final generation
#' @param s The list of data.frames to summarize over (generated by plot.courter.reps or equivalent)
#' @return A data.frame containing the last generation of each rep, the courter frequency, the courter fitness, and the non-courter fitness
#' @export
get.courter.freqs<-function(s){
  courter.final.freqs<-do.call(rbind,lapply(s,function(dat){
    last<-dat[nrow(dat),]
    return(last[,c("Generation","CourterFreq","CourterW","NonCourterW")])
  }))
  if(is.null(names(s))){
    rownames(courter.final.freqs)<-unlist(lapply(seq(1:nrow(courter.final.freqs)),
                                                 function(n){paste("Rep",n,sep="")}))
  }else{
    rownames(courter.final.freqs)<-names(s)
  }
  return(courter.final.freqs)
}

#' Plot parent frequencies for all of the reps
#' @param pattern The pattern for the filenames containing the reps whose parent freqs you want to plot
#' @param cols A vector of colors to use - must contain one named "parent"
#' @param x.lim optional specification of x-axis minimum and maximum (default = c(0,12000))
#' @return A list of data.frames containing the summary frequencies from all generations. The length of the list = number of files matching pattern.
#' @export
plot.parent.reps<-function(pattern,path="./",cols,x.lim=c(0,12000),make.plot=TRUE){
  parent.files<-list.files(pattern=pattern,path=path,full.names = TRUE)
  #set up colors
  mycols <- colorRampPalette(c("grey",cols["parent"],"black"))(length(parent.files))[2:(1+length(parent.files))]
  #set up an empty plot
  if(isTRUE(make.plot)){
    plot(0:1,0:1,bty="L",xlab="Generations",ylab="Frequency of Parental Males",
       type='n',xlim=x.lim,ylim=c(0,1))
  }
  #plot each run's output and save it
  s<-lapply(parent.files,function(file){
    if(length(grep("gz$",file)>0)){
      summ<-suppressWarnings(read.delim(gzfile(file)))
    }else{
      summ<-suppressWarnings(read.delim(file))
    }
    sp<-by(summ,summ$Pop,function(pop){ #break it into each population in the file
      pop<-pop[,which(!colnames(pop)%in%grep("Marker",colnames(pop),value = TRUE))] #only keep the frequency data
      pop<-pop[!is.na(pop$ParentFreq),]
      n<-as.numeric(gsub("\\w+.*_(\\d+)_\\w+.*","\\1",file))
      if(isTRUE(make.plot)){
        points(pop$Generation,pop$ParentFreq,col=alpha(mycols[n],0.5),
             lwd=2,type="l")
      }
      return(pop)
    })
    names(sp)<-paste(file,1:length(sp),sep="_")
    return(as.list(sp))
  })
  if(isTRUE(make.plot)){
    text(x=10000,y=1.1,xpd=TRUE,"Equilibrium\nevaluated")
    clip(x1 = 0,x2=12000,y1=-0.1,y2=1.04)
    abline(v=10000,lty=2,lwd=2)
  }
  s<-do.call(c,s) 
  return(s)
}


#' Create a table of parent frequencies in the final generation
#' @param s The list of data.frames to summarize over (generated by plot.parent.reps or equivalent)
#' @return A data.frame containing the last generation of each rep, the parent frequency, the parent fitness, and the non-parent fitness
#' @export
get.parent.freqs<-function(s){
  parent.final.freqs<-do.call(rbind,lapply(s,function(dat){
    last<-dat[nrow(dat),]
    return(last[,c("Generation","ParentFreq","ParentW","NonParentW")])
  }))
  if(is.null(names(s))){
    rownames(parent.final.freqs)<-unlist(lapply(seq(1:nrow(parent.final.freqs)),
                                                function(n){paste("Rep",n,sep="")}))
  }else{
    rownames(parent.final.freqs)<-names(s)
  }
  return(parent.final.freqs)
}

#' Plot parent and courter frequencies for all of the reps
#' @param pattern The pattern for the filenames containing the reps whose courter and parent freqs you want to plot
#' @param cols A vector of colors to use - must contain one named "parent" and one named "courter"
#' @param x.lim optional specification of x-axis minimum and maximum (default = c(0,12000))
#' @return A list of data.frames containing the summary frequencies from all generations. The length of the list = number of files matching pattern.
#' @note This is often difficult to interpret.
#' @export
plot.pc.reps<-function(pattern,path="./",cols,x.lim=c(0,12000),make.plot=TRUE){
  pc.files<-list.files(pattern=pattern,path=path,full.names = TRUE)
  #set up colors
  parent.cols <- colorRampPalette(c("grey",cols["parent"],"black"))(length(pc.files))[2:(1+length(pc.files))]
  courtr.cols <- colorRampPalette(c("grey",cols["courter"],"black"))(length(pc.files))[2:(1+length(pc.files))]
  #set up an empty plot
  if(isTRUE(make.plot)){
    par(mar=c(4,4,4,4))
    plot(0:1,0:1,bty="U",xlab="Generations",ylab="Frequency of Courter Males",
         type='n',xlim=x.lim,ylim=c(0,1))
    axis(4)
    mtext("Frequency of Parental Males",4,line=2)
  }
  #plot each run's output and save it
  s<-lapply(pc.files,function(file){
    if(length(grep("gz$",file)>0)){
      summ<-suppressWarnings(read.delim(gzfile(file)))
    }else{
      summ<-suppressWarnings(read.delim(file))
    }
    sp<-by(summ,summ$Pop,function(pop){ #break it into each population in the file
      pop<-pop[,which(!colnames(pop)%in%grep("Marker",colnames(pop),value = TRUE))] #only keep the frequency data
      pop<-pop[!is.na(pop$ParentFreq),]
      n<-as.numeric(gsub("\\w+.*_(\\d+)_\\w+.*","\\1",file))
      if(isTRUE(make.plot)){
        points(pop$Generation,pop$CourterFreq,col=alpha(courtr.cols[n],0.5),
               lwd=2,type="l")
        points(pop$Generation,pop$ParentFreq,col=alpha(parent.cols[n],0.5),
               lwd=2,type="l")
      }
      if(length(grep("AE",colnames(pop)))==0){
        browser()
        pop<-cbind(pop,ParentAEmean=NA,ParentAEsd=NA,CourterAEmean=NA,CourterAEsd=NA)
      }
      rownames(pop)<-NULL
      return(pop)
    })
    names(sp)<-paste(file,1:length(sp),sep="_")
    return(as.list(sp))
  })
  if(isTRUE(make.plot)){
    text(x=10000,y=1.1,xpd=TRUE,"Equilibrium\nevaluated")
    clip(x1 = 0,x2=12000,y1=-0.1,y2=1.09)
    abline(v=10000,lty=2,lwd=2)
  }
  s<-do.call(c,s) 
  return(s)
}

#' Plot frequency of four morphs when both courters and parents are present in a population
#' @param s A list of data.frames containing the frequencies to plot (generated by plot.pc.reps)
#' @param cols2 A vector of colors to use - must contain names "NCNP","CNP","NCP", and "CP"
#' @export
plot.morphs.reps<-function(s,cols2,ncols=5,lwd=2,...){
  nrows<-length(s)/ncols
  par(mfrow=c(nrows,ncols),mar=c(2,2,2,1),oma=c(2,2,2,2),...)
  lapply(s,function(summ){
    plot(0:1,0:1,bty="L",xlab="",ylab="",
         type='n',xlim=c(0,12000),ylim=c(0,1))
    points(summ$Generation, summ$FreqNcNp,type="l",col=cols2["NCNP"],lwd=lwd)
    points(summ$Generation, summ$FreqCNp,type="l",col=cols2["CNP"],lwd=lwd)
    points(summ$Generation, summ$FreqNcP,type="l",col=cols2["NCP"],lwd=lwd)
    points(summ$Generation, summ$FreqCP,type="l",col=cols2["CP"],lwd=lwd)

  })
  mtext("Frequency of Morphs",2,outer=TRUE,cex=par()$cex)
  mtext("Generations",1,outer=TRUE,cex=par()$cex)
  
  par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), mar=c(0, 0, 0, 0), new=TRUE)
  plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
  legend("top",c("Courter/Parent","Non-Courter/Parent","Courter/Non-Parent","Non-courter/Non-parent"),
         col=cols2,bty='n',ncol = 2,lty=1,lwd=lwd)
}


#' Extract the frequencies of the morphs in the final generation of each rep
#' @param s A list of data.frames containing the frequencies to extract (generated by plot.pc.reps)
#' @param gen Either "first", "last", or a number indicating which generation's information you want to extract. Default is 'last'.
#' @return A data.frame containing the frequencies in last generation of each rep
#' @export
get.morph.freqs<-function(s, gen="last"){
  gen<-tolower(gen)
  pc.final.freqs<-do.call(rbind,lapply(s,function(dat, gen){
    if(nrow(dat)==0) 
    {
      dat[1,]<-NA
    }
    if(gen == "last"){
      thisdat<-dat[nrow(dat),]  
    }else if(gen == "first"){
      thisdat<-dat[1,]
    }else if(is.numeric(gen)){
      thisdat <- dat[gen,]
    }else{
      print("WARNING: generation choice not recognized. The last generation is being used.")
      thisdat<-dat[nrow(dat),]
    }
    return(thisdat)
  },gen=gen))
  if(is.null(names(s))){
    rownames(pc.final.freqs)<-unlist(lapply(seq(1:nrow(pc.final.freqs)),function(n){paste("Rep",n,sep="")}))
  }else{
    rownames(pc.final.freqs)<-names(s)
  }
  return(pc.final.freqs)
}

#' Plot preference frequencies for all of the reps
#' @param pref A list of data.frames containing the frequencies to plot (generated by plot.pc.reps or equivalent)
#' @param col A vector of colors to use 
#' @param x.lim optional specification of x-axis minimum and maximum (default = c(0,12000))
#' @param ylabel optional label for the y-axis (default is "Frequency of Preference for Courter")
#' @return A list of data.frames containing the summary frequencies from all generations. The length of the list = number of files matching pattern.
#' @export
plot.pref.freqs<-function(pref,col,x.lim=c(0,12000),ylabel="Frequency of Preference for Courter"){
  mycols <- colorRampPalette(col)(length(pref))[2:(1+length(pref))]
  #set up an empty plot
  plot(0:1,0:1,bty="L",xlab="Generations",ylab=ylabel,
       type='n',xlim=x.lim,ylim=c(0,1))
  #plot each run's output and save it
  m<-mapply(function(summ,n){
    points(summ$Generation,summ$PrefFreq,col=alpha(mycols[n],0.5),
           lwd=2,type="l")
  },pref,c(1:length(pref)))
  text(x=10000,y=1.1,xpd=TRUE,"Equilibrium\nevaluated")
  clip(x1 = 0,x2=12000,y1=-0.1,y2=1.04)
  abline(v=10000,lty=2,lwd=2)
}

#' Extract the frequencies of the preferences in the final generation of each rep
#' @param pref A list of data.frames containing the frequencies to plot (generated by plot.pc.reps)
#' @return A data.frame containing the frequencies in last generation of each rep
#' @export
get.pref.freqs<-function(pref){
  pref.final.freqs<-do.call(rbind,lapply(pref,function(dat){
    last<-dat[nrow(dat),]
    return(last[,c("Generation","PrefFreq","PrefThresh")])
  }))
  if(is.null(names(s))){
    rownames(pref.final.freqs)<-unlist(lapply(seq(1:nrow(pref.final.freqs)),
                                              function(n){paste("Rep",n,sep="")}))
  }else{
    rownames(pref.final.freqs)<-names(s)
  }
  return(pref.final.freqs)
}

#' Extract the frequencies of the preferences in the final generation of each rep
#' @param files A list of marker file names to loop over
#' @param twocols Two colors, which will alternate as chromosome backgrounds
#' @param qtl.name The name to look for in the QTL file to extract the correct qtls (e.g. "CourterQTL")
#' @param court.label A binary variable. If true, the courter frequency is written on the graph
#' @param parent.label A binary variable. If true, the parent frequency is written on the graph
#' @param prow A number determining how many rows will be present in the multi-panel plot
#' @return a list with the allele frequencies in the final generation from each file
#' @export
plot.final.maf<-function(files,twocols,qtl.name,qtl.name2=NA,
                         court.label=TRUE,parent.label=FALSE,prow=2,
                         qtl.col="purple",qtl.col2="black",smooth=FALSE,sm.col="black"){
  
  par(mfrow=c(prow,ceiling(length(files)/prow)),mar=c(2,2,2,2),oma=c(2,2,2,2))
  l<-lapply(files, function(file){
    if(length(grep("gz$",file)>0)){
      summ<-suppressWarnings(read.delim(gzfile(file)))
    }else{
      summ<-suppressWarnings(read.delim(file))
    }
    maf<-summ[nrow(summ),which(colnames(summ)%in%grep("Marker",colnames(summ),value = TRUE))]
    #get the qtl info
    aqtls<-read.delim(gsub("markers","qtlinfo",file))
    qtls<-aqtls[,which(colnames(aqtls)%in%grep(qtl.name,colnames(aqtls),value=TRUE))]
    qtls<-unlist(lapply(qtls,function(q){ paste("Marker",q,sep="") }))
    
    #plot
    plot(0:1,0:1,bty="L",xlab="Position on Chrom",ylab="Major Allele Frequency",
         type='n',xlim=c(0,ncol(maf)),ylim=c(0,1))
    for(i in 1:ncol(maf)){
      chr<-as.numeric(gsub("Marker(\\d+).\\d+","\\1",colnames(maf)[i]))+1
      if(chr %% 2 == 0) { color<- twocols[1] }else{ color<-twocols[2] }
      points(i,maf[i],pch=19,col=alpha(color,0.5))
    }
    if(smooth==TRUE){
      sm<-loess.smooth(1:ncol(maf),maf,span=0.1,degree=2)
      points(sm$x,sm$y,type="l",col=sm.col,lwd=2)
    }
    points(which(colnames(maf) %in% qtls),
           maf[which(colnames(maf) %in% qtls)],pch=8,col=qtl.col,cex=2,lwd=2,xpd=TRUE)
    colnames(maf)[colnames(maf)%in% qtls]<-paste(qtl.name,colnames(maf)[colnames(maf)%in% qtls],sep=".")
    if(!is.na(qtl.name2)){
      qtls2<-aqtls[,which(colnames(aqtls)%in%grep(qtl.name2,colnames(aqtls),value=TRUE))]
      qtls2<-unlist(lapply(qtls2,function(q){ paste("Marker",q,sep="") }))
      points(which(colnames(maf) %in% qtls2),
             maf[which(colnames(maf) %in% qtls2)],pch=8,col=qtl.col2,cex=2,lwd=2,xpd=TRUE)
      colnames(maf)[colnames(maf)%in% qtls2]<-paste(qtl.name2,colnames(maf)[colnames(maf)%in% qtls2],sep=".")
    }
    if(court.label==TRUE)
      text(x=2000,y=0.2,labels = paste("Courter Frequency = ", summ[nrow(summ),"CourterFreq"]))
    if(parent.label==TRUE)
      text(x=2000,y=0.15,labels = paste("Parent Frequency = ", summ[nrow(summ),"ParentFreq"]))
    rm(summ)
    
    return(maf)
  })
  return(l)
}


#' Extract the frequencies of the preferences in the final generation of each rep
#' @param maf A list of one generation of allele frequencies (generated by plot.final.maf)
#' @param qtlcol The color for the distribution of QTLs
#' @param qtl.name The name to look for in the QTL file to extract the correct qtls (e.g. "CourterQTL"). If not specified, it will just look for "QTL" in the column names
#' @param nullcol Color for the non-QTL markers (defaults to darkgrey)
#' @param qtl.name2 Optionally, a second QTL name to use to plot a second set of QTL allele frequencies separately
#' @param qtlcol2 When qtl.name2 is specified, you can specify a color to use. Defaults to light blue.
#' @param prow A number determining how many rows will be present in the multi-panel plot
#' @return a list with the allele frequencies in the final generation from each file
#' @export
plot.afs<-function(maf,qtlcol,prow,qtl.name="QTL",nullcol="darkgrey",
                   qtl.name2=NA,qtlcol2=NA){
  par(mfrow=c(prow,ceiling(length(maf)/prow)),mar=c(2,2,2,2),oma=c(2,2,2,2))
  afs<-lapply(maf,function(af){
    #get the values
    h1<-hist(as.numeric(af[grep(qtl.name,colnames(af),invert=TRUE)]),plot = FALSE,breaks=10)
    h2<-hist(as.numeric(af[grep(qtl.name,colnames(af))]),plot = FALSE,breaks=10)
    if(is.na(qtl.name2)){
      ymax<-ceiling(max(h1$density,h2$density))
    }else{
      h3<-hist(as.numeric(af[grep(qtl.name2,colnames(af))]),plot = FALSE,breaks=10)
      ymax<-ceiling(max(h1$density,h2$density,h3$density))
    }
    #plot
    hist(as.numeric(af[grep(qtl.name,colnames(af),invert=TRUE)]),col=alpha(nullcol,0.5),border=nullcol,
         main="",xlab="",ylab="",xlim=c(0.5,1),ylim=c(0,ymax),breaks=10,density=4,axes=FALSE,freq=FALSE)
    hist(as.numeric(af[grep(qtl.name,colnames(af))]),col=alpha(qtlcol,0.5),
         border=qtlcol,freq=FALSE,breaks=10,main="",xlab="",ylab="",xlim=c(0.5,1),ylim=c(0,ymax),
         add=TRUE)
    if(!is.na(qtl.name2)){
      if(is.na(qtlcol2)){ qtlcol2<-"lightblue" }
      hist(as.numeric(af[grep(qtl.name2,colnames(af))]),col=alpha(qtlcol2,0.5),
           border=qtlcol2,freq=FALSE,breaks=10,main="",xlab="",ylab="",xlim=c(0.5,1),ylim=c(0,ymax),
           add=TRUE)
    }
    axis(1,pos=0)
    axis(2,pos=0.5,las=1)
  })
  mtext("Major allele frequency",1,outer=TRUE,cex=0.85)
  mtext("Density",2,outer=TRUE,cex=0.85)
}


#' Plot the final frequencies of morphs for a variety of parameter values
#' @param freqs A data.frame with the morph frequencies
#' @param x_name The name of the column with x-axis values (e.g. "ParentSurvival")
#' @param cols2 Colors for the backgrounds
#' @param x_lab Label for the x-axis
#' @param x_lim Limits for the x-axis
#' @param yname_pos The location of the y-axis labels'
#' @param xaxt Defaults to 's', but you can use any of the valid plot parameters
#' @export
plot_morph_freqs<-function(freqs,x_name,cols2,x_lab=NA,x_lim=NA,yname_pos=NA,xaxt='s'){
  freqs[,x_name]<-as.numeric(freqs[,x_name])
  if(length(x_lim) == 1){
    x_lim<-c(min(freqs[,x_name])-0.05,max(freqs[,x_name])+0.05)  
  }
  if(is.na(x_lab)){
    x_lab<-x_name
  }
  if(is.na(yname_pos)){
    yname_pos<-x_lim[1]-0.05
  }
  plot(freqs[,x_name],freqs$FreqNcNp,ylim=c(0,4.3),xlim=x_lim,xaxt=xaxt,
       yaxt='n',xlab=x_lab,ylab="",type = 'n',frame.plot = FALSE)
  rect(xleft = x_lim[1],ybottom = 0,xright = x_lim[2]+0.05,ytop = 1,col=alpha(cols2["NCNP"],0.25),border = NA)
  rect(xleft = x_lim[1],ybottom = 1.1,xright = x_lim[2]+0.05,ytop = 2.1,col=alpha(cols2["NCP"],0.25),border = NA)
  rect(xleft = x_lim[1],ybottom = 2.2,xright = x_lim[2]+0.05,ytop = 3.2,col=alpha(cols2["CNP"],0.25),border = NA)
  rect(xleft = x_lim[1],ybottom = 3.3,xright = x_lim[2]+0.05,ytop = 4.3,col=alpha(cols2["CP"],0.25),border = NA)
  points(jitter(freqs[,x_name]),freqs$FreqNcNp,pch=0) #scale up one
  points(jitter(freqs[,x_name]),freqs$FreqNcP+1.1,pch=1) #scale up one
  points(jitter(freqs[,x_name]),freqs$FreqCNp+2.2,pch=2) #scale up two
  points(jitter(freqs[,x_name]),freqs$FreqCP+3.3,pch=5) #scale up three
  text(x = yname_pos,y = 0.5,"Non-Courter-\nNon-Parent\nFrequency",xpd=TRUE,srt=90)
  text(x = yname_pos,y = 1.6,"Non-Courter-\nParent\nFrequency",xpd=TRUE,srt=90)
  text(x = yname_pos,y = 2.7,"Courter-\nNon-Parent\nFrequency",xpd=TRUE,srt=90)
  text(x = yname_pos,y = 3.8,"Courter-\nParent\nFrequency",xpd=TRUE,srt=90)
  axis(2,at=c(0,1,1.1,2.1,2.2,3.2,3.3,4.3),labels = c(0,1,0,1,0,1,0,1),pos = x_lim[1],las=1,lwd=0)
}

#' Generate the tables of summary statistics for final frequencies
#' @param base_pattern The base pattern for all of the files (e.g. courter_linked) used to find and read the files in the directory
#' @param x_name The name of the column with x-axis values (e.g. "ParentSurvival")
#' @param qtl.name The name to look for in the QTL file to extract the correct qtls (e.g. "CourterQTL"). If not specified, it will just look for "QTL" in the column names
#' @param cols Colors for plot.reps
#' @param summ_list String or list of strings containing column names that you want means and SEM for
#' @param type specify "courter", "parent" or "morphs" to specify which functions to call
#' @return data.frame containing labels, the parameter values, and the means and standard errors across the runs
#' @export
summarize_params<-function(base_pattern="^courter_linked",cols,summ_list="CourterFreq",type){
  #get baselines
  if(tolower(type) == "courter"){
    baseline<-plot.courter.reps(pattern=paste(base_pattern,".*_summary.txt",sep=""),path="baseline",cols,make.plot=FALSE)
    baseline_freqs<-get.courter.freqs(baseline)[,-1]
  }else if(tolower(type) == "parent"){
    baseline<-plot.parent.reps(pattern=paste(base_pattern,".*_summary.txt",sep=""),path="baseline",cols,make.plot=FALSE)
    baseline_freqs<-get.parent.freqs(baseline)[,-1]
  }else if(tolower(type) == "morphs"){
    baseline<-plot.pc.reps(pattern=paste(base_pattern,".*_summary.txt",sep=""),path="baseline",cols,make.plot=FALSE)
    baseline_freqs<-get.morph.freqs(baseline)[,-1]
  }else{
    stop("you must correctly specify the type of function call")
  }
  baseline_freqs$Polygyny<-FALSE
  baseline_freqs$CourterRS<-8
  baseline_freqs$NoncourterRS<-4
  baseline_freqs$ParentSurvival<-0.9
  baseline_freqs$NonparentSurvival<-0.1
  baseline_freqs$Courter2NonRS<-as.factor(as.numeric(baseline_freqs$CourterRS)/as.numeric(baseline_freqs$NoncourterRS))
  baseline_freqs$SupergeneProportion<-0.1
  rm(baseline)
  
  #polygyny
  if(tolower(type) == "courter"){
    polygyny<-plot.courter.reps(pattern=paste(base_pattern,"_polygyny.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    polygyny_freqs<-get.courter.freqs(polygyny)[,-1]
  }else if(tolower(type) == "parent"){
    polygyny<-plot.parent.reps(pattern=paste(base_pattern,"_polygyny.*_summary.txt(.*)?",sep=""),path="sensitivity",cols,make.plot=FALSE)
    polygyny_freqs<-get.parent.freqs(polygyny)[,-1]
  }else if(tolower(type) == "morphs"){
    polygyny<-plot.pc.reps(pattern=paste(base_pattern,"_polygyny.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    polygyny_freqs<-get.morph.freqs(polygyny)[,-1]
  }
  polygyny_freqs$Polygyny<-TRUE
  polygyny_freqs<-rbind(polygyny_freqs[,c(summ_list,"Polygyny")],baseline_freqs[,c(summ_list,"Polygyny")])
  rm(polygyny)
 
  #RS
  if(tolower(type) == "courter"){
    rs<-plot.courter.reps(pattern=paste(base_pattern,"_crs.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    rs_freqs<-get.courter.freqs(rs)[,-1]
  }else if(tolower(type) == "parent"){
    rs<-plot.parent.reps(pattern=paste(base_pattern,"_crs.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    rs_freqs<-get.parent.freqs(rs)[,-1]
  }else if(tolower(type) == "morphs"){
    rs<-plot.pc.reps(pattern=paste(base_pattern,"_crs.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    rs_freqs<-get.morph.freqs(rs)[,-1]
  }
  rs_freqs$CourterRS<-gsub(".*crs(\\d)_ncrs\\d.*","\\1",rownames(rs_freqs))
  rs_freqs$NoncourterRS<-gsub(".*crs\\d_ncrs(\\d).*","\\1",rownames(rs_freqs))
  rs_freqs$Courter2NonRS<-as.factor(as.numeric(rs_freqs$CourterRS)/as.numeric(rs_freqs$NoncourterRS))
  rs_freqs<-rbind(rs_freqs[,c(summ_list,"CourterRS","NoncourterRS","Courter2NonRS")],baseline_freqs[,c(summ_list,"CourterRS","NoncourterRS","Courter2NonRS")])
  rm(rs)
  
  #Parent nest survival
  if(tolower(type) == "courter"){
    psurv<-plot.courter.reps(pattern=paste(base_pattern,"_psurv.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    psurv_freqs<-get.courter.freqs(psurv)[,-1]
  }else if(tolower(type) == "parent"){
    psurv<-plot.parent.reps(pattern=paste(base_pattern,"_psurv.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    psurv_freqs<-get.parent.freqs(psurv)[,-1]
  }else if(tolower(type) == "morphs"){
    psurv<-plot.pc.reps(pattern=paste(base_pattern,"_psurv.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    psurv_freqs<-get.morph.freqs(psurv)[,-1]
  }
  psurv_freqs$ParentSurvival<-gsub(".*psurv(\\d.\\d).*","\\1",rownames(psurv_freqs))
  psurv_freqs<-rbind(psurv_freqs[,c(summ_list,"ParentSurvival")],baseline_freqs[,c(summ_list,"ParentSurvival")])
  rm(psurv)
  
  #Non parent nest survival
  if(tolower(type) == "courter"){
    npsurv<-plot.courter.reps(pattern=paste(base_pattern,"_npsurv.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    npsurv_freqs<-get.courter.freqs(npsurv)[,-1]
  }else if(tolower(type) == "parent"){
    npsurv<-plot.parent.reps(pattern=paste(base_pattern,"_npsurv.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    npsurv_freqs<-get.parent.freqs(npsurv)[,-1]
  }else if(tolower(type) == "morphs"){
    npsurv<-plot.pc.reps(pattern=paste(base_pattern,"_npsurv.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    npsurv_freqs<-get.morph.freqs(npsurv)[,-1]
  }
  npsurv_freqs$NonparentSurvival<-gsub(".*npsurv(\\d.\\d).*","\\1",rownames(npsurv_freqs))
  npsurv_freqs<-rbind(npsurv_freqs[,c(summ_list,"NonparentSurvival")],baseline_freqs[,c(summ_list,"NonparentSurvival")])
  rm(npsurv)
  
  #supergene proportion
  if(tolower(type) == "courter"){
    supprop<-plot.courter.reps(pattern=paste(base_pattern,".*prop.*_summary.txt(.*)?",sep=""),path="sensitivity",cols,make.plot=FALSE)
    supprop_freqs<-get.courter.freqs(supprop)[,-1]
  }else if(tolower(type) == "parent"){
    supprop<-plot.parent.reps(pattern=paste(base_pattern,".*prop.*_summary.txt(.*)?",sep=""),path="sensitivity",cols,make.plot=FALSE)
    supprop_freqs<-get.parent.freqs(supprop)[,-1]
  }else if(tolower(type) == "morphs"){
    supprop<-plot.pc.reps(pattern=paste(base_pattern,".*prop.*_summary.txt(.*)?",sep=""),path="sensitivity",cols,make.plot=FALSE)
    supprop_freqs<-get.morph.freqs(supprop)[,-1]
  }
  supprop_freqs$SupergeneProportion<-gsub(".*prop(\\d.\\d+).*","\\1",rownames(supprop_freqs))
  supprop_freqs<-rbind(supprop_freqs[,c(summ_list,"SupergeneProportion")],baseline_freqs[,c(summ_list,"SupergeneProportion")])
  rm(supprop)
  
  #calc the summary stats
  summary_stats<-do.call(rbind,lapply(list(polygyny_freqs,rs_freqs,psurv_freqs,npsurv_freqs,supprop_freqs),function(freqs,summ_list){
    output<-lapply(summ_list,function(summ){
      m<-tapply(freqs[,summ],freqs[,ncol(freqs)],mean)
      sem<-tapply(freqs[,summ],freqs[,ncol(freqs)],function(x){ sd(x)/length(x) })
      param_lab<-gsub(paste(".*",substr(base_pattern,2,nchar(base_pattern)),"_(\\w+).*_summary.txt.*",sep=""),"\\1",rownames(freqs)[1])
      output<-data.frame(param_label=param_lab,params=names(m),means=m,sem=as.numeric(sem))
      colnames(output)<-c("param_label","params",paste(summ," Mean",sep=""),paste(summ," SEM",sep=""))
      return(output)
    })
    output<-do.call(cbind,output)
    output<-output[,unique(colnames(output))]
    return(output)
  },summ_list=summ_list))
  
  return(summary_stats)
}

#' Create violin plots with 
#' @param ... legend parameters
#' @return Optionally returns the summary statistics of the data.
#' @notes Modified from vioplot() in library(vioplot)
#' @example 
#' mu<-2
#' si<-0.6
#' bimodal<-c(rnorm(1000,-mu,si),rnorm(1000,mu,si))
#' uniform<-runif(2000,-4,4)
#' normal<-rnorm(2000,0,3)
#' gwsca.vioplot(bimodal,uniform,normal,col=c("red","blue","green"))
#' @include sm
#' @export
violinplot <- function(x,...,range=1.5,h=NULL,ylim=NULL,names=NULL, horizontal=FALSE,
                          col="magenta", border="black", lty=1, lwd=1, rectCol="black", colMed="white", pchMed=19, at, add=FALSE, wex=1,
                          drawRect=TRUE,plot.axes=TRUE,axis.box=FALSE,plot.ann=TRUE)
{
  # process multiple datas
  datas <- list(x,...)
  n <- length(datas)
  
  if(missing(at)) at <- 1:n
  
  # pass 1
  #
  # - calculate base range
  # - estimate density
  #
  
  # setup parameters for density estimation
  upper  <- vector(mode="numeric",length=n)
  lower  <- vector(mode="numeric",length=n)
  q1     <- vector(mode="numeric",length=n)
  q3     <- vector(mode="numeric",length=n)
  med    <- vector(mode="numeric",length=n)
  base   <- vector(mode="list",length=n)
  height <- vector(mode="list",length=n)
  baserange <- c(Inf,-Inf)
  
  # global args for sm.density function-call
  args <- list(display="none")
  
  if (!(is.null(h)))
    args <- c(args, h=h)
  
  for(i in 1:n) {
    data<-datas[[i]]
    
    # calculate plot parameters
    #   1- and 3-quantile, median, IQR, upper- and lower-adjacent
    data.min <- min(data)
    data.max <- max(data)
    q1[i]<-quantile(data,0.25)
    q3[i]<-quantile(data,0.75)
    med[i]<-median(data)
    iqd <- q3[i]-q1[i]
    upper[i] <- min( q3[i] + range*iqd, data.max )
    lower[i] <- max( q1[i] - range*iqd, data.min )
    
    #   strategy:
    #       xmin = min(lower, data.min))
    #       ymax = max(upper, data.max))
    #
    
    est.xlim <- c( min(lower[i], data.min), max(upper[i], data.max) )
    
    # estimate density curve
    smout <- do.call("sm.density", c( list(data, xlim=est.xlim), args ) )
    
    # calculate stretch factor
    #
    #  the plots density heights is defined in range 0.0 ... 0.5
    #  we scale maximum estimated point to 0.4 per data
    #
    hscale <- 0.4/max(smout$estimate) * wex
    
    # add density curve x,y pair to lists
    base[[i]]   <- smout$eval.points
    height[[i]] <- smout$estimate * hscale
    
    # calculate min,max base ranges
    t <- range(base[[i]])
    baserange[1] <- min(baserange[1],t[1])
    baserange[2] <- max(baserange[2],t[2])
    
  }
  
  # pass 2
  #
  # - plot graphics
  
  # setup parameters for plot
  if(!add){
    xlim <- if(n==1)
      at + c(-.5, .5)
    else
      range(at) + min(diff(at))/2 * c(-1,1)
    
    if (is.null(ylim)) {
      ylim <- baserange
    }
  }
  if (is.null(names)) {
    label <- 1:n
  } else {
    label <- names
  }
  # setup colors and borders
  if(length(col) < n){
    col<-c(col,rep(col,n-length(col)))
  }
  if(length(border)<n){
    border<-c(border,rep(border,n-length(border)))
  }
  if(length(colMed)<n){
    colMed<-c(colMed,rep(colMed,n-length(colMed)))
  }
  boxwidth <- 0.05 * wex
  
  # setup plot
  if(!add)
    plot.new()
  if(!horizontal) {
    if(!add){
      plot.window(xlim = xlim, ylim = ylim)
      if(plot.axes){
        if(plot.ann){
          axis(2)
          axis(1,at = at, label=label )
        }else{
          axis(2,labels=F)
          axis(1,at = at, labels=F )
        }
      }
    }
    
    if(axis.box){ box() }
    for(i in 1:n) {
      # plot left/right density curve
      polygon( c(at[i]-height[[i]], rev(at[i]+height[[i]])),
               c(base[[i]], rev(base[[i]])),
               col = col[i], border=border[i], lty=lty, lwd=lwd)
      
      if(drawRect){
        # plot IQR
        lines( at[c( i, i)], c(lower[i], upper[i]) ,lwd=lwd, lty=lty)
        
        # plot 50% KI box
        rect( at[i]-boxwidth/2, q1[i], at[i]+boxwidth/2, q3[i], col=rectCol)
        
        # plot median point
        points( at[i], med[i], pch=pchMed, col=colMed )
      }
    }
    
  }
  else {
    if(!add){
      plot.window(xlim = ylim, ylim = xlim,bty=axis.bty)
      if(plot.axes){
        if(plot.ann){
          axis(2)
          axis(1,at = at, label=label )
        }else{
          axis(2,labels=F)
          axis(1,at = at, labels=F )
        }
      }
    }
    
    if(axis.box){ box() }
    for(i in 1:n) {
      # plot left/right density curve
      polygon( c(base[[i]], rev(base[[i]])),
               c(at[i]-height[[i]], rev(at[i]+height[[i]])),
               col = col[i], border=border[i], lty=lty, lwd=lwd)
      
      if(drawRect){
        # plot IQR
        lines( c(lower[i], upper[i]), at[c(i,i)] ,lwd=lwd, lty=lty)
        
        # plot 50% KI box
        rect( q1[i], at[i]-boxwidth/2, q3[i], at[i]+boxwidth/2,  col=rectCol)
        
        # plot median point
        points( med[i], at[i], pch=pchMed, col=colMed )
      }
    }
  }
  invisible (list( upper=upper, lower=lower, median=med, q1=q1, q3=q3))
}


#' Plot the final allele frequencies for all replicates
#' @param base_pattern The baseline pattern of file names to look for in the path
#' @param path The path to look in. defaults to ./
#' @param ncols The number of columns to plot
#' @param cols The colors for the plots
#' @param ... Parameters passed to par()
#' @return A data.frame with the frequencies for courter and parent QTLs for each population in the final generation of the simulations
#' @export
plot_final_af<-function(base_pattern,path="./",ncols=4,cols,...){
   
  mrk_files<-list.files(pattern=paste(base_pattern,"markers.txt",sep="_"),path=path,full.names = TRUE)
  qtl_files<-list.files(pattern=paste(base_pattern,"qtlinfo.txt",sep="_"),path=path,full.names = TRUE)
  nrows<-length(mrk_files) #and there will be ncols per file
  par(mfrow=c(nrows,ncols),mar=c(1,1,1,1),oma=c(2,2.5,2,2))#,...
  
  dat<-mapply(function(mrk_file,qtl_file){
    if(length(grep("gz$",mrk_file)>0)){
      mrks<-suppressWarnings(read.delim(gzfile(mrk_file)))
    }else{
      mrks<-suppressWarnings(read.delim(mrk_file))
    }
    if(length(grep("gz$",qtl_file)>0)){
      qtls<-suppressWarnings(read.delim(gzfile(qtl_file)))
    }else{
      qtls<-suppressWarnings(read.delim(qtl_file))
    }
    qtls<-qtls[,complete.cases(t(qtls))] #remove columns with nas
    
    qtl_final_freq<-do.call(rbind,lapply(levels(qtls$Pop),function(pop){
      qtl_af<-cbind(mrks[,1:2],mrks[,colnames(mrks) %in% paste("Marker",qtls[qtls$Pop %in% pop,-1],sep="")])
      qtl_af<-qtl_af[qtl_af$Pop%in% pop,] #only save the ones for this pop
      
      courter_qtls<-paste("Marker",qtls[qtls$Pop %in% pop,grep("Courter",colnames(qtls))],sep="")
      parent_qtls<-paste("Marker",qtls[qtls$Pop %in% pop,grep("Parent",colnames(qtls))],sep="")
      
      #reorganzie
      qtl_dat<-data.frame(freqs=as.numeric(qtl_af[which.max(qtl_af$Generation),3:ncol(qtl_af)]),
                          pop=rep(pop,length(3:ncol(qtl_af))),
                          trait=rep("Courter",length(3:ncol(qtl_af))),stringsAsFactors = FALSE)
      qtl_dat$trait[(which(colnames(qtl_af) %in% parent_qtls)-2)]<-"Parent"
      
      #plot
      violinplot(qtl_dat$freqs[qtl_dat$trait=="Courter"],qtl_dat$freqs[qtl_dat$trait=="Parent"],
                 col=alpha(cols[c("courter","parent")],0.5),plot.axes = FALSE,border=cols[c("courter","parent")],ylim=c(0,1))
      points(jitter(rep(1,length(qtl_dat$freqs[qtl_dat$trait=="Courter"]))),qtl_dat$freqs[qtl_dat$trait=="Courter"],col=cols["courter"],pch=19)
      points(jitter(rep(2,length(qtl_dat$freqs[qtl_dat$trait=="Parent"]))),qtl_dat$freqs[qtl_dat$trait=="Parent"],col=cols["parent"],pch=19)
      axis(1,at=c(1,2),labels = c("Courter QTLs","ParentQTLs"),lwd=0)
      axis(2)
      return(qtl_dat)
    }))
    
    qtl_final_freq$label<-mrk_file
    return(qtl_final_freq)
    
    
  },mrk_file=mrk_files,qtl_file=qtl_files)
  
  mtext("Allele Frequency",2,outer=TRUE,line=1)
  
  invisible(return(dat))
}

plot_final_traits<-function(pattern,path="./",ncols=4,cols,cols2){
  trait_files<-list.files(pattern=pattern,path=path,full.names = TRUE)
  trait_files<-trait_files[sapply(trait_files,file.size)>0] # skip any that are empty
  nrows<-length(trait_files) #and there will be ncols per file
  par(mfrow=c(nrows,ncols),mar=c(1,2,1,1),oma=c(2,2.5,3,2))#,...
  loopdeloop<-lapply(trait_files,function(trait_file,cols2){
    if(length(grep("gz$",trait_file)>0)){
      tryCatch(traits<-suppressWarnings(read.delim(gzfile(trait_file))),error=function(e){
        print(paste("Reading error with file ",trait_file))
      })
      #traits<-suppressWarnings(read.delim(gzfile(trait_file)))
    }else{
      traits<-suppressWarnings(read.delim(trait_file))
    }
    trtplot<-lapply(unique(traits$Pop),function(pop,traits,cols2){
      trt<-traits[traits$Pop == pop,]
      ymin<-round(min(c(trt$CourtTrait,trt$ParentTrait)),digits = 0)-1
      ymax<-round(max(c(trt$CourtTrait,trt$ParentTrait)),digits = 0)+1
      plot(c(0,1),xlim=c(0.5,2.5),ylim=c(ymin,ymax),axes=FALSE,type='n',xlab="",xaxt='n',ylab="Allelic effects")
      abline(h = 0,lty=3,col="grey")
      #axis(1,at=c(1,2),labels = c("Courter","Parent"),lwd=0,lwd.ticks = 0,cex.axis=2,pos=ymin)
      axis(2,cex.axis=1.5,las=1)
      #ADD THE COURTER/NONCOURTER AND PARENT/NONPARENT COLORS
      crtpch<-trt$Courter
      prtpch<-trt$Parent
      points(jitter(rep(1,nrow(trt))),trt$CourtTrait,pch=crtpch,col=cols["courter"],cex=2)
      points(jitter(rep(2,nrow(trt))),trt$ParentTrait,pch=prtpch,col=cols["parent"],cex=2)
      n<-apply(trt,1,function(trow,cols2){
        if(trow["Courter"]==1 & trow["Parent"]==1){
          thiscol<-cols2["CP"]
        }
        if(trow["Courter"]==1 & trow["Parent"]==0){
          thiscol<-cols2["CNP"]
        }
        if(trow["Courter"]==0 & trow["Parent"]==1){
          thiscol<-cols2["NCP"]
        }
        if(trow["Courter"]==0 & trow["Parent"]==0){
          thiscol<-cols2["NCNP"]
        }
        lines(x=c(1,2),y=c(trow["CourtTrait"],trow["ParentTrait"]),col=alpha(thiscol,0.5))
      },cols2=cols2)
      
    },traits=traits,cols2=cols2)
  },cols2=cols2)
  
  mtext("Trait values",2,outer=TRUE,line=1)
  
  #add outer legend
  par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), mar=c(0, 0, 0, 0), new=TRUE)
  plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
  legend("topleft",c("Courter","Non-Courter","Parent","Non-Parent"),
         pt.bg=c(rep(alpha(cols["courter"],0.5),2),rep(alpha(cols["parent"],0.5),2)),
         col=c(rep(cols["courter"],2),rep(cols["parent"],2)),bty='n',ncol = 2,
         pch=c(1,0,1,0),cex=1.5,pt.cex = 2)
  
  legend("topright",c("Courter/Parent","Non-Courter/Parent","Courter/Non-Parent","Non-courter/Non-parent"),
         col=cols2,bty='n',ncol = 2,lty=1,cex=1.5,lwd=2)
}


plot_2vars_summary<-function(all_freqs,xvar,yvar,xlab="Relative reproductive allocation (courter/non-courter)",ylab="Relative nest survival (parent/non-parent)",...){
  
  #Plotting setup
  nx<-length(unique(as.numeric(all_freqs[,xvar]))) #number of values on x axis
  ny<-length(unique(as.numeric(all_freqs[,yvar]))) #number of values on y axis
  all_freqs$Rep<-as.numeric(factor(rownames(all_freqs[order(all_freqs[,xvar]),]))) # make rep in order of RS
  all_freqs$xloc<-as.numeric(as.factor(all_freqs[,xvar]))
  all_freqs$yloc<-as.numeric(as.factor(all_freqs[,yvar]))
  
  all_freqs$paramsets<-gsub(".*/parent-courter_[a-z]+_(.*)_\\d+_summary.txt(.gz)?_\\d+","\\1",rownames(all_freqs))
  
  newlocs<-do.call(rbind,lapply(unique(all_freqs$paramsets),function(p,all_freqs){  
    newlocs<-all_freqs[all_freqs$paramsets==p,]$xloc+seq(-0.4,0.4,length.out = nrow(all_freqs[all_freqs$paramsets==p,]))
    return(cbind(Rep=all_freqs[all_freqs$paramsets==p,"Rep"],newlocs))
  },all_freqs=all_freqs))
  
  plot_freqs<-merge(all_freqs,newlocs,by="Rep")
  
  par(...)
  par(mfrow=c(ny,nx),mar=c(0.5,0.5,0.5,0.5),oma=c(3,3,3,1))
  # need to go across x axis and down y axis
  for(y in unique(as.numeric(all_freqs[,yvar]))[order(unique(as.numeric(all_freqs[,yvar])),decreasing = TRUE)]){
    for(x in unique(as.numeric(all_freqs[,xvar]))[order(unique(as.numeric(all_freqs[,xvar])))]){    
      dat<-plot_freqs[plot_freqs[,xvar]==x & plot_freqs[,yvar]==y,]
      if(nrow(dat)>0){
        
        barplot(t(as.matrix(dat[,c("FreqNcNp","FreqCNp","FreqNcP","FreqCP")])),
                col=cols2[c("NCNP","CNP","NCP","CP")],
                names.arg = rep("",ncol(t(as.matrix(dat[,c("FreqNcNp","FreqCNp","FreqNcP","FreqCP")])))),
                axes=FALSE,
                border=NA,
                space=0.1)
      }else{
        plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
      }
      if(x==min(as.numeric(all_freqs[,xvar]))){
        mtext(round(y,1),2,las=2)
      }
      if(y==min(as.numeric(all_freqs[,yvar]))){
        mtext(round(x,1),1)
      }
    }
  }
  mtext(xlab,1,outer=TRUE,line=1.5)
  mtext(ylab,2,outer=TRUE,line=1.5)
  
  par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), mar=c(0, 0, 0, 0), new=TRUE)
  plot(as.numeric(all_freqs[,xvar]),
       as.numeric(all_freqs[,yvar]), type='n', bty='n', xaxt='n', yaxt='n')
   legend("top",bty='n',legend = c("Courter/Parent","Courter/Non-parent","Non-courter/Parent","Non-courter/Non-parent"),
         col=cols2[c("CP","CNP","NCP","NCNP")],pch=15,xpd = TRUE,ncol=2,cex=1.25)
  
}
