#Author: Sarah P. Flanagan (spflanagan.phd@gmail.com)

#' Plot courter frequencies for all of the reps
#' @param pattern The pattern for the filenames containing the reps whose courter freqs you want to plot
#' @param cols A vector of colors to use - must contain one named "courter"
#' @param x.lim optional specification of x-axis minimum and maximum (default = c(0,12000))
#' @return A list of data.frames containing the summary frequencies from all generations. The length of the list = number of files matching pattern.
#' @export
plot.courter.reps<-function(pattern,cols,x.lim=c(0,12000)){
  courter.files<-list.files(pattern=pattern)
  #set up colors
  mycols <- colorRampPalette(c("grey",cols["courter"],"black"))(length(courter.files)+1)[2:(1+length(courter.files))]
  #set up an empty plot
  plot(0:1,0:1,bty="L",xlab="Generations",ylab="Frequency of Courting Males",
       type='n',xlim=x.lim,ylim=c(0,1))
  #plot each run's output and save it
  s<-lapply(courter.files,function(file){
    summ<-suppressWarnings(read.delim(file))
    sp<-by(summ,summ$Pop,function(pop){ #break it into each population in the file
      pop<-pop[,which(!colnames(pop)%in%grep("Marker",colnames(pop),value = TRUE))] #only keep the frequency data
      pop<-pop[!is.na(pop$CourterFreq),]
      n<-as.numeric(gsub("\\w+.*_(\\d+)_\\w+.*","\\1",file))
      points(pop$Generation,pop$CourterFreq,col=alpha(mycols[n],0.5),
             lwd=2,type="l")
      return(pop)
    })
    names(sp)<-paste(file,1:length(sp),sep="_")
    return(as.list(sp))
  })
  text(x=10000,y=1.1,xpd=TRUE,"End of initial\ngenerations")
  clip(x1 = 0,x2=12000,y1=-0.1,y2=1.04)
  abline(v=10000,lty=2,lwd=2)
  s<-do.call(c,s) #flatten out the list of lists
  return(s)
}

#' Create a table of courter frequencies in the final generation
#' @param s The list of data.frames to summarize over (generated by plot.courter.reps or equivalent)
#' @return A data.frame containing the last generation of each rep, the courter frequency, the courter fitness, and the non-courter fitness
#' @export
get.courter.freqs<-function(s){
  courter.final.freqs<-do.call(rbind,lapply(s,function(dat){
    last<-dat[nrow(dat),]
    return(last[,c("Generation","CourterFreq","CourterW","NonCourterW")])
  }))
  if(is.null(names(s))){
    rownames(courter.final.freqs)<-unlist(lapply(seq(1:nrow(courter.final.freqs)),
                                                 function(n){paste("Rep",n,sep="")}))
  }else{
    rownames(courter.final.freqs)<-names(s)
  }
  return(courter.final.freqs)
}

#' Plot parent frequencies for all of the reps
#' @param pattern The pattern for the filenames containing the reps whose parent freqs you want to plot
#' @param cols A vector of colors to use - must contain one named "parent"
#' @param x.lim optional specification of x-axis minimum and maximum (default = c(0,12000))
#' @return A list of data.frames containing the summary frequencies from all generations. The length of the list = number of files matching pattern.
#' @export
plot.parent.reps<-function(pattern,cols,x.lim=c(0,12000)){
  parent.files<-list.files(pattern=pattern)
  #set up colors
  mycols <- colorRampPalette(c("grey",cols["parent"],"black"))(length(parent.files))[2:(1+length(parent.files))]
  #set up an empty plot
  plot(0:1,0:1,bty="L",xlab="Generations",ylab="Frequency of Parental Males",
       type='n',xlim=x.lim,ylim=c(0,1))
  #plot each run's output and save it
  s<-lapply(parent.files,function(file){
    summ<-suppressWarnings(read.delim(file))
    sp<-by(summ,summ$Pop,function(pop){ #break it into each population in the file
      pop<-pop[,which(!colnames(pop)%in%grep("Marker",colnames(pop),value = TRUE))] #only keep the frequency data
      pop<-pop[!is.na(pop$ParentFreq),]
      n<-as.numeric(gsub("\\w+.*_(\\d+)_\\w+.*","\\1",file))
      points(pop$Generation,pop$ParentFreq,col=alpha(mycols[n],0.5),
             lwd=2,type="l")
      return(pop)
    })
    names(sp)<-paste(file,1:length(sp),sep="_")
    return(as.list(sp))
  })
  text(x=10000,y=1.1,xpd=TRUE,"Equilibrium\nevaluated")
  clip(x1 = 0,x2=12000,y1=-0.1,y2=1.04)
  abline(v=10000,lty=2,lwd=2)
  s<-do.call(c,s) 
  return(s)
}


#' Create a table of parent frequencies in the final generation
#' @param s The list of data.frames to summarize over (generated by plot.parent.reps or equivalent)
#' @return A data.frame containing the last generation of each rep, the parent frequency, the parent fitness, and the non-parent fitness
#' @export
get.parent.freqs<-function(s){
  parent.final.freqs<-do.call(rbind,lapply(s,function(dat){
    last<-dat[nrow(dat),]
    return(last[,c("Generation","ParentFreq","ParentW","NonParentW")])
  }))
  if(is.null(names(s))){
    rownames(parent.final.freqs)<-unlist(lapply(seq(1:nrow(parent.final.freqs)),
                                                function(n){paste("Rep",n,sep="")}))
  }else{
    rownames(parent.final.freqs)<-names(s)
  }
  return(parent.final.freqs)
}

#' Plot parent and courter frequencies for all of the reps
#' @param pattern The pattern for the filenames containing the reps whose courter and parent freqs you want to plot
#' @param cols A vector of colors to use - must contain one named "parent" and one named "courter"
#' @param x.lim optional specification of x-axis minimum and maximum (default = c(0,12000))
#' @return A list of data.frames containing the summary frequencies from all generations. The length of the list = number of files matching pattern.
#' @note This is often difficult to interpret.
#' @export
plot.pc.reps<-function(pattern,cols,x.lim=c(0,12000),make.plot=TRUE){
  pc.files<-list.files(pattern=pattern)
  #set up colors
  parent.cols <- colorRampPalette(c("grey",cols["parent"],"black"))(length(pc.files))[2:(1+length(pc.files))]
  courtr.cols <- colorRampPalette(c("grey",cols["courter"],"black"))(length(pc.files))[2:(1+length(pc.files))]
  #set up an empty plot
  if(isTRUE(make.plot)){
    par(mar=c(4,4,4,4))
    plot(0:1,0:1,bty="U",xlab="Generations",ylab="Frequency of Courter Males",
         type='n',xlim=x.lim,ylim=c(0,1))
    axis(4)
    mtext("Frequency of Parental Males",4,line=2)
  }
  #plot each run's output and save it
  s<-lapply(pc.files,function(file){
    summ<-suppressWarnings(read.delim(file))
    sp<-by(summ,summ$Pop,function(pop){ #break it into each population in the file
      pop<-pop[,which(!colnames(pop)%in%grep("Marker",colnames(pop),value = TRUE))] #only keep the frequency data
      pop<-pop[!is.na(pop$ParentFreq),]
      n<-as.numeric(gsub("\\w+.*_(\\d+)_\\w+.*","\\1",file))
      if(isTRUE(make.plot)){
        points(pop$Generation,pop$CourterFreq,col=alpha(courtr.cols[n],0.5),
               lwd=2,type="l")
        points(pop$Generation,pop$ParentFreq,col=alpha(parent.cols[n],0.5),
               lwd=2,type="l")
      }
      return(pop)
    })
    names(sp)<-paste(file,1:length(sp),sep="_")
    return(as.list(sp))
  })
  if(isTRUE(make.plot)){
    text(x=10000,y=1.1,xpd=TRUE,"Equilibrium\nevaluated")
    clip(x1 = 0,x2=12000,y1=-0.1,y2=1.09)
    abline(v=10000,lty=2,lwd=2)
  }
  s<-do.call(c,s) 
  return(s)
}

#' Plot frequency of four morphs when both courters and parents are present in a population
#' @param s A list of data.frames containing the frequencies to plot (generated by plot.pc.reps)
#' @param cols2 A vector of colors to use - must contain names "NCNP","CNP","NCP", and "CP"
#' @export
plot.morphs.reps<-function(s,cols2,ncols=5){
  nrows<-length(s)/ncols
  par(mfrow=c(nrows,ncols),mar=c(2,2,2,1),oma=c(2,2,2,2))
  lapply(s,function(summ){
    plot(0:1,0:1,bty="L",xlab="",ylab="",
         type='n',xlim=c(0,12000),ylim=c(0,1))
    points(summ$Generation, summ$FreqNcNp,type="l",col=cols2["NCNP"],lwd=2)
    points(summ$Generation, summ$FreqCNp,type="l",col=cols2["CNP"],lwd=2)
    points(summ$Generation, summ$FreqNcP,type="l",col=cols2["NCP"],lwd=2)
    points(summ$Generation, summ$FreqCP,type="l",col=cols2["CP"],lwd=2)

  })
  mtext("Frequency of Morphs",2,outer=TRUE,cex=0.8)
  mtext("Generations",1,outer=TRUE,cex=0.8)
  
  par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), mar=c(0, 0, 0, 0), new=TRUE)
  plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
  legend("top",c("Courter/Parent","Non-Courter/Parent","Courter/Non-Parent","Non-courter/Non-parent"),
         col=cols2,bty='n',ncol = 4,lty=1,lwd=2)
}


#' Extract the frequencies of the morphs in the final generation of each rep
#' @param s A list of data.frames containing the frequencies to plot (generated by plot.pc.reps)
#' @return A data.frame containing the frequencies in last generation of each rep
#' @export
get.morph.freqs<-function(s){
  pc.final.freqs<-do.call(rbind,lapply(s,function(dat){
    last<-dat[nrow(dat),]
    return(last[,c(1,11:14)])
  }))
  if(is.null(names(s))){
    rownames(pc.final.freqs)<-unlist(lapply(seq(1:nrow(pc.final.freqs)),function(n){paste("Rep",n,sep="")}))
  }else{
    rownames(pc.final.freqs)<-names(s)
  }
  return(pc.final.freqs)
}

#' Plot preference frequencies for all of the reps
#' @param pref A list of data.frames containing the frequencies to plot (generated by plot.pc.reps or equivalent)
#' @param col A vector of colors to use 
#' @param x.lim optional specification of x-axis minimum and maximum (default = c(0,12000))
#' @param ylabel optional label for the y-axis (default is "Frequency of Preference for Courter")
#' @return A list of data.frames containing the summary frequencies from all generations. The length of the list = number of files matching pattern.
#' @export
plot.pref.freqs<-function(pref,col,x.lim=c(0,12000),ylabel="Frequency of Preference for Courter"){
  mycols <- colorRampPalette(col)(length(pref))[2:(1+length(pref))]
  #set up an empty plot
  plot(0:1,0:1,bty="L",xlab="Generations",ylab=ylabel,
       type='n',xlim=x.lim,ylim=c(0,1))
  #plot each run's output and save it
  m<-mapply(function(summ,n){
    points(summ$Generation,summ$PrefFreq,col=alpha(mycols[n],0.5),
           lwd=2,type="l")
  },pref,c(1:length(pref)))
  text(x=10000,y=1.1,xpd=TRUE,"Equilibrium\nevaluated")
  clip(x1 = 0,x2=12000,y1=-0.1,y2=1.04)
  abline(v=10000,lty=2,lwd=2)
}

#' Extract the frequencies of the preferences in the final generation of each rep
#' @param pref A list of data.frames containing the frequencies to plot (generated by plot.pc.reps)
#' @return A data.frame containing the frequencies in last generation of each rep
#' @export
get.pref.freqs<-function(pref){
  pref.final.freqs<-do.call(rbind,lapply(pref,function(dat){
    last<-dat[nrow(dat),]
    return(last[,c("Generation","PrefFreq","PrefThresh")])
  }))
  if(is.null(names(s))){
    rownames(pref.final.freqs)<-unlist(lapply(seq(1:nrow(pref.final.freqs)),
                                              function(n){paste("Rep",n,sep="")}))
  }else{
    rownames(pref.final.freqs)<-names(s)
  }
  return(pref.final.freqs)
}

#' Extract the frequencies of the preferences in the final generation of each rep
#' @param files A list of summary file names to loop over
#' @param twocols Two colors, which will alternate as chromosome backgrounds
#' @param qtl.name The name to look for in the QTL file to extract the correct qtls (e.g. "CourterQTL")
#' @param court.label A binary variable. If true, the courter frequency is written on the graph
#' @param parent.label A binary variable. If true, the parent frequency is written on the graph
#' @param prow A number determining how many rows will be present in the multi-panel plot
#' @return a list with the allele frequencies in the final generation from each file
#' @export
plot.final.maf<-function(files,twocols,qtl.name,qtl.name2=NA,
                         court.label=TRUE,parent.label=FALSE,prow=2,
                         qtl.col="purple",qtl.col2="black",smooth=FALSE,sm.col="black"){
  
  par(mfrow=c(prow,ceiling(length(files)/prow)),mar=c(2,2,2,2),oma=c(2,2,2,2))
  l<-lapply(files, function(file){
    summ<-suppressWarnings(read.delim(file))
    maf<-summ[nrow(summ),which(colnames(summ)%in%grep("Marker",colnames(summ),value = TRUE))]
    #get the qtl info
    aqtls<-read.delim(gsub("summary","qtlinfo",file))
    qtls<-aqtls[,which(colnames(aqtls)%in%grep(qtl.name,colnames(aqtls),value=TRUE))]
    qtls<-unlist(lapply(qtls,function(q){ paste("Marker",q,sep="") }))
    
    #plot
    plot(0:1,0:1,bty="L",xlab="Position on Chrom",ylab="Major Allele Frequency",
         type='n',xlim=c(0,ncol(maf)),ylim=c(0,1))
    for(i in 1:ncol(maf)){
      chr<-as.numeric(gsub("Marker(\\d+).\\d+","\\1",colnames(maf)[i]))+1
      if(chr %% 2 == 0) { color<- twocols[1] }else{ color<-twocols[2] }
      points(i,maf[i],pch=19,col=alpha(color,0.5))
    }
    if(smooth==TRUE){
      sm<-loess.smooth(1:ncol(maf),maf,span=0.1,degree=2)
      points(sm$x,sm$y,type="l",col=sm.col,lwd=2)
    }
    points(which(colnames(maf) %in% qtls),
           maf[which(colnames(maf) %in% qtls)],pch=8,col=qtl.col,cex=2,lwd=2,xpd=TRUE)
    colnames(maf)[colnames(maf)%in% qtls]<-paste(qtl.name,colnames(maf)[colnames(maf)%in% qtls],sep=".")
    if(!is.na(qtl.name2)){
      qtls2<-aqtls[,which(colnames(aqtls)%in%grep(qtl.name2,colnames(aqtls),value=TRUE))]
      qtls2<-unlist(lapply(qtls2,function(q){ paste("Marker",q,sep="") }))
      points(which(colnames(maf) %in% qtls2),
             maf[which(colnames(maf) %in% qtls2)],pch=8,col=qtl.col2,cex=2,lwd=2,xpd=TRUE)
      colnames(maf)[colnames(maf)%in% qtls2]<-paste(qtl.name2,colnames(maf)[colnames(maf)%in% qtls2],sep=".")
    }
    if(court.label==TRUE)
      text(x=2000,y=0.2,labels = paste("Courter Frequency = ", summ[nrow(summ),"CourterFreq"]))
    if(parent.label==TRUE)
      text(x=2000,y=0.15,labels = paste("Parent Frequency = ", summ[nrow(summ),"ParentFreq"]))
    rm(summ)
    
    return(maf)
  })
  return(l)
}


#' Extract the frequencies of the preferences in the final generation of each rep
#' @param maf A list of one generation of allele frequencies (generated by plot.final.maf)
#' @param qtlcol The color for the distribution of QTLs
#' @param qtl.name The name to look for in the QTL file to extract the correct qtls (e.g. "CourterQTL"). If not specified, it will just look for "QTL" in the column names
#' @param nullcol Color for the non-QTL markers (defaults to darkgrey)
#' @param qtl.name2 Optionally, a second QTL name to use to plot a second set of QTL allele frequencies separately
#' @param qtlcol2 When qtl.name2 is specified, you can specify a color to use. Defaults to light blue.
#' @param prow A number determining how many rows will be present in the multi-panel plot
#' @return a list with the allele frequencies in the final generation from each file
#' @export
plot.afs<-function(maf,qtlcol,prow,qtl.name="QTL",nullcol="darkgrey",
                   qtl.name2=NA,qtlcol2=NA){
  par(mfrow=c(prow,ceiling(length(maf)/prow)),mar=c(2,2,2,2),oma=c(2,2,2,2))
  afs<-lapply(maf,function(af){
    #get the values
    h1<-hist(as.numeric(af[grep(qtl.name,colnames(af),invert=TRUE)]),plot = FALSE,breaks=10)
    h2<-hist(as.numeric(af[grep(qtl.name,colnames(af))]),plot = FALSE,breaks=10)
    if(is.na(qtl.name2)){
      ymax<-ceiling(max(h1$density,h2$density))
    }else{
      h3<-hist(as.numeric(af[grep(qtl.name2,colnames(af))]),plot = FALSE,breaks=10)
      ymax<-ceiling(max(h1$density,h2$density,h3$density))
    }
    #plot
    hist(as.numeric(af[grep(qtl.name,colnames(af),invert=TRUE)]),col=alpha(nullcol,0.5),border=nullcol,
         main="",xlab="",ylab="",xlim=c(0.5,1),ylim=c(0,ymax),breaks=10,density=4,axes=FALSE,freq=FALSE)
    hist(as.numeric(af[grep(qtl.name,colnames(af))]),col=alpha(qtlcol,0.5),
         border=qtlcol,freq=FALSE,breaks=10,main="",xlab="",ylab="",xlim=c(0.5,1),ylim=c(0,ymax),
         add=TRUE)
    if(!is.na(qtl.name2)){
      if(is.na(qtlcol2)){ qtlcol2<-"lightblue" }
      hist(as.numeric(af[grep(qtl.name2,colnames(af))]),col=alpha(qtlcol2,0.5),
           border=qtlcol2,freq=FALSE,breaks=10,main="",xlab="",ylab="",xlim=c(0.5,1),ylim=c(0,ymax),
           add=TRUE)
    }
    axis(1,pos=0)
    axis(2,pos=0.5,las=1)
  })
  mtext("Major allele frequency",1,outer=TRUE,cex=0.85)
  mtext("Density",2,outer=TRUE,cex=0.85)
}
