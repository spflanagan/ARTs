#Author: Sarah P. Flanagan (spflanagan.phd@gmail.com)

#' Plot courter frequencies for all of the reps
#' @param pattern The pattern for the filenames containing the reps whose courter freqs you want to plot
#' @param cols A vector of colors to use - must contain one named "courter"
#' @param x.lim optional specification of x-axis minimum and maximum (default = c(0,12000))
#' @return A list of data.frames containing the summary frequencies from all generations. The length of the list = number of files matching pattern.
#' @export
plot.courter.reps<-function(pattern,path="./",cols,x.lim=c(0,12000),make.plot=TRUE){
  courter.files<-list.files(pattern=pattern,path=path,full.names = TRUE)
  #set up colors
  mycols <- colorRampPalette(c("grey",cols["courter"],"black"))(length(courter.files)+1)[2:(1+length(courter.files))]
  #set up an empty plot
  if(isTRUE(make.plot)){
    plot(0:1,0:1,bty="L",xlab="Generations",ylab="Frequency of Courting Males",
       type='n',xlim=x.lim,ylim=c(0,1))
  }
  #plot each run's output and save it
  s<-lapply(courter.files,function(file){
    summ<-suppressWarnings(read.delim(file))
    sp<-by(summ,summ$Pop,function(pop){ #break it into each population in the file
      pop<-pop[,which(!colnames(pop)%in%grep("Marker",colnames(pop),value = TRUE))] #only keep the frequency data
      pop<-pop[!is.na(pop$CourterFreq),]
      n<-as.numeric(gsub("\\w+.*_(\\d+)_\\w+.*","\\1",file))
      if(isTRUE(make.plot)){
        points(pop$Generation,pop$CourterFreq,col=alpha(mycols[n],0.5),
             lwd=2,type="l")
      }
      return(pop)
    })
    names(sp)<-paste(file,1:length(sp),sep="_")
    return(as.list(sp))
  })
  if(isTRUE(make.plot)){
    text(x=10000,y=1.1,xpd=TRUE,"End of initial\ngenerations")
    clip(x1 = 0,x2=12000,y1=-0.1,y2=1.04)
    abline(v=10000,lty=2,lwd=2)
  }
  s<-do.call(c,s) #flatten out the list of lists
  return(s)
}

#' Create a table of courter frequencies in the final generation
#' @param s The list of data.frames to summarize over (generated by plot.courter.reps or equivalent)
#' @return A data.frame containing the last generation of each rep, the courter frequency, the courter fitness, and the non-courter fitness
#' @export
get.courter.freqs<-function(s){
  courter.final.freqs<-do.call(rbind,lapply(s,function(dat){
    last<-dat[nrow(dat),]
    return(last[,c("Generation","CourterFreq","CourterW","NonCourterW")])
  }))
  if(is.null(names(s))){
    rownames(courter.final.freqs)<-unlist(lapply(seq(1:nrow(courter.final.freqs)),
                                                 function(n){paste("Rep",n,sep="")}))
  }else{
    rownames(courter.final.freqs)<-names(s)
  }
  return(courter.final.freqs)
}

#' Plot parent frequencies for all of the reps
#' @param pattern The pattern for the filenames containing the reps whose parent freqs you want to plot
#' @param cols A vector of colors to use - must contain one named "parent"
#' @param x.lim optional specification of x-axis minimum and maximum (default = c(0,12000))
#' @return A list of data.frames containing the summary frequencies from all generations. The length of the list = number of files matching pattern.
#' @export
plot.parent.reps<-function(pattern,path="./",cols,x.lim=c(0,12000),make.plot=TRUE){
  parent.files<-list.files(pattern=pattern,path=path,full.names = TRUE)
  #set up colors
  mycols <- colorRampPalette(c("grey",cols["parent"],"black"))(length(parent.files))[2:(1+length(parent.files))]
  #set up an empty plot
  if(isTRUE(make.plot)){
    plot(0:1,0:1,bty="L",xlab="Generations",ylab="Frequency of Parental Males",
       type='n',xlim=x.lim,ylim=c(0,1))
  }
  #plot each run's output and save it
  s<-lapply(parent.files,function(file){
    summ<-suppressWarnings(read.delim(file))
    sp<-by(summ,summ$Pop,function(pop){ #break it into each population in the file
      pop<-pop[,which(!colnames(pop)%in%grep("Marker",colnames(pop),value = TRUE))] #only keep the frequency data
      pop<-pop[!is.na(pop$ParentFreq),]
      n<-as.numeric(gsub("\\w+.*_(\\d+)_\\w+.*","\\1",file))
      if(isTRUE(make.plot)){
        points(pop$Generation,pop$ParentFreq,col=alpha(mycols[n],0.5),
             lwd=2,type="l")
      }
      return(pop)
    })
    names(sp)<-paste(file,1:length(sp),sep="_")
    return(as.list(sp))
  })
  if(isTRUE(make.plot)){
    text(x=10000,y=1.1,xpd=TRUE,"Equilibrium\nevaluated")
    clip(x1 = 0,x2=12000,y1=-0.1,y2=1.04)
    abline(v=10000,lty=2,lwd=2)
  }
  s<-do.call(c,s) 
  return(s)
}


#' Create a table of parent frequencies in the final generation
#' @param s The list of data.frames to summarize over (generated by plot.parent.reps or equivalent)
#' @return A data.frame containing the last generation of each rep, the parent frequency, the parent fitness, and the non-parent fitness
#' @export
get.parent.freqs<-function(s){
  parent.final.freqs<-do.call(rbind,lapply(s,function(dat){
    last<-dat[nrow(dat),]
    return(last[,c("Generation","ParentFreq","ParentW","NonParentW")])
  }))
  if(is.null(names(s))){
    rownames(parent.final.freqs)<-unlist(lapply(seq(1:nrow(parent.final.freqs)),
                                                function(n){paste("Rep",n,sep="")}))
  }else{
    rownames(parent.final.freqs)<-names(s)
  }
  return(parent.final.freqs)
}

#' Plot parent and courter frequencies for all of the reps
#' @param pattern The pattern for the filenames containing the reps whose courter and parent freqs you want to plot
#' @param cols A vector of colors to use - must contain one named "parent" and one named "courter"
#' @param x.lim optional specification of x-axis minimum and maximum (default = c(0,12000))
#' @return A list of data.frames containing the summary frequencies from all generations. The length of the list = number of files matching pattern.
#' @note This is often difficult to interpret.
#' @export
plot.pc.reps<-function(pattern,path="./",cols,x.lim=c(0,12000),make.plot=TRUE){
  pc.files<-list.files(pattern=pattern,path=path,full.names = TRUE)
  #set up colors
  parent.cols <- colorRampPalette(c("grey",cols["parent"],"black"))(length(pc.files))[2:(1+length(pc.files))]
  courtr.cols <- colorRampPalette(c("grey",cols["courter"],"black"))(length(pc.files))[2:(1+length(pc.files))]
  #set up an empty plot
  if(isTRUE(make.plot)){
    par(mar=c(4,4,4,4))
    plot(0:1,0:1,bty="U",xlab="Generations",ylab="Frequency of Courter Males",
         type='n',xlim=x.lim,ylim=c(0,1))
    axis(4)
    mtext("Frequency of Parental Males",4,line=2)
  }
  #plot each run's output and save it
  s<-lapply(pc.files,function(file){
    summ<-suppressWarnings(read.delim(file))
    sp<-by(summ,summ$Pop,function(pop){ #break it into each population in the file
      pop<-pop[,which(!colnames(pop)%in%grep("Marker",colnames(pop),value = TRUE))] #only keep the frequency data
      pop<-pop[!is.na(pop$ParentFreq),]
      n<-as.numeric(gsub("\\w+.*_(\\d+)_\\w+.*","\\1",file))
      if(isTRUE(make.plot)){
        points(pop$Generation,pop$CourterFreq,col=alpha(courtr.cols[n],0.5),
               lwd=2,type="l")
        points(pop$Generation,pop$ParentFreq,col=alpha(parent.cols[n],0.5),
               lwd=2,type="l")
      }
      return(pop)
    })
    names(sp)<-paste(file,1:length(sp),sep="_")
    return(as.list(sp))
  })
  if(isTRUE(make.plot)){
    text(x=10000,y=1.1,xpd=TRUE,"Equilibrium\nevaluated")
    clip(x1 = 0,x2=12000,y1=-0.1,y2=1.09)
    abline(v=10000,lty=2,lwd=2)
  }
  s<-do.call(c,s) 
  return(s)
}

#' Plot frequency of four morphs when both courters and parents are present in a population
#' @param s A list of data.frames containing the frequencies to plot (generated by plot.pc.reps)
#' @param cols2 A vector of colors to use - must contain names "NCNP","CNP","NCP", and "CP"
#' @export
plot.morphs.reps<-function(s,cols2,ncols=5,lwd=2,...){
  nrows<-length(s)/ncols
  par(mfrow=c(nrows,ncols),mar=c(2,2,2,1),oma=c(2,2,2,2),...)
  lapply(s,function(summ){
    plot(0:1,0:1,bty="L",xlab="",ylab="",
         type='n',xlim=c(0,12000),ylim=c(0,1))
    points(summ$Generation, summ$FreqNcNp,type="l",col=cols2["NCNP"],lwd=lwd)
    points(summ$Generation, summ$FreqCNp,type="l",col=cols2["CNP"],lwd=lwd)
    points(summ$Generation, summ$FreqNcP,type="l",col=cols2["NCP"],lwd=lwd)
    points(summ$Generation, summ$FreqCP,type="l",col=cols2["CP"],lwd=lwd)

  })
  mtext("Frequency of Morphs",2,outer=TRUE,cex=par()$cex)
  mtext("Generations",1,outer=TRUE,cex=par()$cex)
  
  par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), mar=c(0, 0, 0, 0), new=TRUE)
  plot(0, 0, type='n', bty='n', xaxt='n', yaxt='n')
  legend("top",c("Courter/Parent","Non-Courter/Parent","Courter/Non-Parent","Non-courter/Non-parent"),
         col=cols2,bty='n',ncol = 2,lty=1,lwd=lwd)
}


#' Extract the frequencies of the morphs in the final generation of each rep
#' @param s A list of data.frames containing the frequencies to plot (generated by plot.pc.reps)
#' @return A data.frame containing the frequencies in last generation of each rep
#' @export
get.morph.freqs<-function(s){
  pc.final.freqs<-do.call(rbind,lapply(s,function(dat){
    last<-dat[nrow(dat),]
    return(last)
  }))
  if(is.null(names(s))){
    rownames(pc.final.freqs)<-unlist(lapply(seq(1:nrow(pc.final.freqs)),function(n){paste("Rep",n,sep="")}))
  }else{
    rownames(pc.final.freqs)<-names(s)
  }
  return(pc.final.freqs)
}

#' Plot preference frequencies for all of the reps
#' @param pref A list of data.frames containing the frequencies to plot (generated by plot.pc.reps or equivalent)
#' @param col A vector of colors to use 
#' @param x.lim optional specification of x-axis minimum and maximum (default = c(0,12000))
#' @param ylabel optional label for the y-axis (default is "Frequency of Preference for Courter")
#' @return A list of data.frames containing the summary frequencies from all generations. The length of the list = number of files matching pattern.
#' @export
plot.pref.freqs<-function(pref,col,x.lim=c(0,12000),ylabel="Frequency of Preference for Courter"){
  mycols <- colorRampPalette(col)(length(pref))[2:(1+length(pref))]
  #set up an empty plot
  plot(0:1,0:1,bty="L",xlab="Generations",ylab=ylabel,
       type='n',xlim=x.lim,ylim=c(0,1))
  #plot each run's output and save it
  m<-mapply(function(summ,n){
    points(summ$Generation,summ$PrefFreq,col=alpha(mycols[n],0.5),
           lwd=2,type="l")
  },pref,c(1:length(pref)))
  text(x=10000,y=1.1,xpd=TRUE,"Equilibrium\nevaluated")
  clip(x1 = 0,x2=12000,y1=-0.1,y2=1.04)
  abline(v=10000,lty=2,lwd=2)
}

#' Extract the frequencies of the preferences in the final generation of each rep
#' @param pref A list of data.frames containing the frequencies to plot (generated by plot.pc.reps)
#' @return A data.frame containing the frequencies in last generation of each rep
#' @export
get.pref.freqs<-function(pref){
  pref.final.freqs<-do.call(rbind,lapply(pref,function(dat){
    last<-dat[nrow(dat),]
    return(last[,c("Generation","PrefFreq","PrefThresh")])
  }))
  if(is.null(names(s))){
    rownames(pref.final.freqs)<-unlist(lapply(seq(1:nrow(pref.final.freqs)),
                                              function(n){paste("Rep",n,sep="")}))
  }else{
    rownames(pref.final.freqs)<-names(s)
  }
  return(pref.final.freqs)
}

#' Extract the frequencies of the preferences in the final generation of each rep
#' @param files A list of summary file names to loop over
#' @param twocols Two colors, which will alternate as chromosome backgrounds
#' @param qtl.name The name to look for in the QTL file to extract the correct qtls (e.g. "CourterQTL")
#' @param court.label A binary variable. If true, the courter frequency is written on the graph
#' @param parent.label A binary variable. If true, the parent frequency is written on the graph
#' @param prow A number determining how many rows will be present in the multi-panel plot
#' @return a list with the allele frequencies in the final generation from each file
#' @export
plot.final.maf<-function(files,twocols,qtl.name,qtl.name2=NA,
                         court.label=TRUE,parent.label=FALSE,prow=2,
                         qtl.col="purple",qtl.col2="black",smooth=FALSE,sm.col="black"){
  
  par(mfrow=c(prow,ceiling(length(files)/prow)),mar=c(2,2,2,2),oma=c(2,2,2,2))
  l<-lapply(files, function(file){
    summ<-suppressWarnings(read.delim(file))
    maf<-summ[nrow(summ),which(colnames(summ)%in%grep("Marker",colnames(summ),value = TRUE))]
    #get the qtl info
    aqtls<-read.delim(gsub("summary","qtlinfo",file))
    qtls<-aqtls[,which(colnames(aqtls)%in%grep(qtl.name,colnames(aqtls),value=TRUE))]
    qtls<-unlist(lapply(qtls,function(q){ paste("Marker",q,sep="") }))
    
    #plot
    plot(0:1,0:1,bty="L",xlab="Position on Chrom",ylab="Major Allele Frequency",
         type='n',xlim=c(0,ncol(maf)),ylim=c(0,1))
    for(i in 1:ncol(maf)){
      chr<-as.numeric(gsub("Marker(\\d+).\\d+","\\1",colnames(maf)[i]))+1
      if(chr %% 2 == 0) { color<- twocols[1] }else{ color<-twocols[2] }
      points(i,maf[i],pch=19,col=alpha(color,0.5))
    }
    if(smooth==TRUE){
      sm<-loess.smooth(1:ncol(maf),maf,span=0.1,degree=2)
      points(sm$x,sm$y,type="l",col=sm.col,lwd=2)
    }
    points(which(colnames(maf) %in% qtls),
           maf[which(colnames(maf) %in% qtls)],pch=8,col=qtl.col,cex=2,lwd=2,xpd=TRUE)
    colnames(maf)[colnames(maf)%in% qtls]<-paste(qtl.name,colnames(maf)[colnames(maf)%in% qtls],sep=".")
    if(!is.na(qtl.name2)){
      qtls2<-aqtls[,which(colnames(aqtls)%in%grep(qtl.name2,colnames(aqtls),value=TRUE))]
      qtls2<-unlist(lapply(qtls2,function(q){ paste("Marker",q,sep="") }))
      points(which(colnames(maf) %in% qtls2),
             maf[which(colnames(maf) %in% qtls2)],pch=8,col=qtl.col2,cex=2,lwd=2,xpd=TRUE)
      colnames(maf)[colnames(maf)%in% qtls2]<-paste(qtl.name2,colnames(maf)[colnames(maf)%in% qtls2],sep=".")
    }
    if(court.label==TRUE)
      text(x=2000,y=0.2,labels = paste("Courter Frequency = ", summ[nrow(summ),"CourterFreq"]))
    if(parent.label==TRUE)
      text(x=2000,y=0.15,labels = paste("Parent Frequency = ", summ[nrow(summ),"ParentFreq"]))
    rm(summ)
    
    return(maf)
  })
  return(l)
}


#' Extract the frequencies of the preferences in the final generation of each rep
#' @param maf A list of one generation of allele frequencies (generated by plot.final.maf)
#' @param qtlcol The color for the distribution of QTLs
#' @param qtl.name The name to look for in the QTL file to extract the correct qtls (e.g. "CourterQTL"). If not specified, it will just look for "QTL" in the column names
#' @param nullcol Color for the non-QTL markers (defaults to darkgrey)
#' @param qtl.name2 Optionally, a second QTL name to use to plot a second set of QTL allele frequencies separately
#' @param qtlcol2 When qtl.name2 is specified, you can specify a color to use. Defaults to light blue.
#' @param prow A number determining how many rows will be present in the multi-panel plot
#' @return a list with the allele frequencies in the final generation from each file
#' @export
plot.afs<-function(maf,qtlcol,prow,qtl.name="QTL",nullcol="darkgrey",
                   qtl.name2=NA,qtlcol2=NA){
  par(mfrow=c(prow,ceiling(length(maf)/prow)),mar=c(2,2,2,2),oma=c(2,2,2,2))
  afs<-lapply(maf,function(af){
    #get the values
    h1<-hist(as.numeric(af[grep(qtl.name,colnames(af),invert=TRUE)]),plot = FALSE,breaks=10)
    h2<-hist(as.numeric(af[grep(qtl.name,colnames(af))]),plot = FALSE,breaks=10)
    if(is.na(qtl.name2)){
      ymax<-ceiling(max(h1$density,h2$density))
    }else{
      h3<-hist(as.numeric(af[grep(qtl.name2,colnames(af))]),plot = FALSE,breaks=10)
      ymax<-ceiling(max(h1$density,h2$density,h3$density))
    }
    #plot
    hist(as.numeric(af[grep(qtl.name,colnames(af),invert=TRUE)]),col=alpha(nullcol,0.5),border=nullcol,
         main="",xlab="",ylab="",xlim=c(0.5,1),ylim=c(0,ymax),breaks=10,density=4,axes=FALSE,freq=FALSE)
    hist(as.numeric(af[grep(qtl.name,colnames(af))]),col=alpha(qtlcol,0.5),
         border=qtlcol,freq=FALSE,breaks=10,main="",xlab="",ylab="",xlim=c(0.5,1),ylim=c(0,ymax),
         add=TRUE)
    if(!is.na(qtl.name2)){
      if(is.na(qtlcol2)){ qtlcol2<-"lightblue" }
      hist(as.numeric(af[grep(qtl.name2,colnames(af))]),col=alpha(qtlcol2,0.5),
           border=qtlcol2,freq=FALSE,breaks=10,main="",xlab="",ylab="",xlim=c(0.5,1),ylim=c(0,ymax),
           add=TRUE)
    }
    axis(1,pos=0)
    axis(2,pos=0.5,las=1)
  })
  mtext("Major allele frequency",1,outer=TRUE,cex=0.85)
  mtext("Density",2,outer=TRUE,cex=0.85)
}


#' Plot the final frequencies of morphs for a variety of parameter values
#' @param freqs A data.frame with the morph frequencies
#' @param x_name The name of the column with x-axis values (e.g. "ParentSurvival")
#' @param cols2 Colors for the backgrounds
#' @param x_lab Label for the x-axis
#' @param x_lim Limits for the x-axis
#' @param yname_pos The location of the y-axis labels'
#' @param xaxt Defaults to 's', but you can use any of the valid plot parameters
#' @export
plot_morph_freqs<-function(freqs,x_name,cols2,x_lab=NA,x_lim=NA,yname_pos=NA,xaxt='s'){
  freqs[,x_name]<-as.numeric(freqs[,x_name])
  if(length(x_lim) == 1){
    x_lim<-c(min(freqs[,x_name])-0.05,max(freqs[,x_name])+0.05)  
  }
  if(is.na(x_lab)){
    x_lab<-x_name
  }
  if(is.na(yname_pos)){
    yname_pos<-x_lim[1]-0.05
  }
  plot(freqs[,x_name],freqs$FreqNcNp,ylim=c(0,4.3),xlim=x_lim,xaxt=xaxt,
       yaxt='n',xlab=x_lab,ylab="",type = 'n',frame.plot = FALSE)
  rect(xleft = x_lim[1],ybottom = 0,xright = x_lim[2]+0.05,ytop = 1,col=alpha(cols2["NCNP"],0.25),border = NA)
  rect(xleft = x_lim[1],ybottom = 1.1,xright = x_lim[2]+0.05,ytop = 2.1,col=alpha(cols2["NCP"],0.25),border = NA)
  rect(xleft = x_lim[1],ybottom = 2.2,xright = x_lim[2]+0.05,ytop = 3.2,col=alpha(cols2["CNP"],0.25),border = NA)
  rect(xleft = x_lim[1],ybottom = 3.3,xright = x_lim[2]+0.05,ytop = 4.3,col=alpha(cols2["CP"],0.25),border = NA)
  points(jitter(freqs[,x_name]),freqs$FreqNcNp,pch=0) #scale up one
  points(jitter(freqs[,x_name]),freqs$FreqNcP+1.1,pch=1) #scale up one
  points(jitter(freqs[,x_name]),freqs$FreqCNp+2.2,pch=2) #scale up two
  points(jitter(freqs[,x_name]),freqs$FreqCP+3.3,pch=5) #scale up three
  text(x = yname_pos,y = 0.5,"Non-Courter-\nNon-Parent\nFrequency",xpd=TRUE,srt=90)
  text(x = yname_pos,y = 1.6,"Non-Courter-\nParent\nFrequency",xpd=TRUE,srt=90)
  text(x = yname_pos,y = 2.7,"Courter-\nNon-Parent\nFrequency",xpd=TRUE,srt=90)
  text(x = yname_pos,y = 3.8,"Courter-\nParent\nFrequency",xpd=TRUE,srt=90)
  axis(2,at=c(0,1,1.1,2.1,2.2,3.2,3.3,4.3),labels = c(0,1,0,1,0,1,0,1),pos = x_lim[1],las=1,lwd=0)
}

#' Plot the final frequencies of morphs for a variety of parameter values
#' @param base_pattern The base pattern for all of the files (e.g. courter_linked) used to find and read the files in the directory
#' @param x_name The name of the column with x-axis values (e.g. "ParentSurvival")
#' @param qtl.name The name to look for in the QTL file to extract the correct qtls (e.g. "CourterQTL"). If not specified, it will just look for "QTL" in the column names
#' @param cols Colors for plot.reps
#' @param summ_list String or list of strings containing column names that you want means and SEM for
#' @param type specify "courter", "parent" or "morphs" to specify which functions to call
#' @return data.frame containing labels, the parameter values, and the means and standard errors across the runs
#' @export
summarize_params<-function(base_pattern="^courter_linked",cols,summ_list="CourterFreq",type){
  #get baselines
  if(tolower(type) == "courter"){
    baseline<-plot.courter.reps(pattern=paste(base_pattern,".*_summary.txt",sep=""),path="baseline",cols,make.plot=FALSE)
    baseline_freqs<-get.courter.freqs(baseline)[,-1]
  }else if(tolower(type) == "parent"){
    baseline<-plot.parent.reps(pattern=paste(base_pattern,".*_summary.txt",sep=""),path="baseline",cols,make.plot=FALSE)
    baseline_freqs<-get.parent.freqs(baseline)[,-1]
  }else if(tolower(type) == "morphs"){
    baseline<-plot.pc.reps(pattern=paste(base_pattern,".*_summary.txt",sep=""),path="baseline",cols,make.plot=FALSE)
    baseline_freqs<-get.morph.freqs(baseline)[,-1]
  }else{
    stop("you must correctly specify the type of function call")
  }
  baseline_freqs$Polygyny<-FALSE
  baseline_freqs$CourterRS<-8
  baseline_freqs$NoncourterRS<-4
  baseline_freqs$ParentSurvival<-0.9
  baseline_freqs$NonparentSurvival<-0.1
  baseline_freqs$Courter2NonRS<-as.factor(as.numeric(baseline_freqs$CourterRS)/as.numeric(baseline_freqs$NoncourterRS))
  rm(baseline)
  
  #polygyny
  if(tolower(type) == "courter"){
    polygyny<-plot.courter.reps(pattern=paste(base_pattern,"_polygyny.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    polygyny_freqs<-get.courter.freqs(polygyny)[,-1]
  }else if(tolower(type) == "parent"){
    polygyny<-plot.parent.reps(pattern=paste(base_pattern,"_polygyny.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    polygyny_freqs<-get.parent.freqs(polygyny)[,-1]
  }else if(tolower(type) == "morphs"){
    polygyny<-plot.pc.reps(pattern=paste(base_pattern,"_polygyny.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    polygyny_freqs<-get.morph.freqs(polygyny)[,-1]
  }
  polygyny_freqs$Polygyny<-TRUE
  polygyny_freqs<-rbind(polygyny_freqs[,c(summ_list,"Polygyny")],baseline_freqs[,c(summ_list,"Polygyny")])
  rm(polygyny)
 
  #RS
  if(tolower(type) == "courter"){
    rs<-plot.courter.reps(pattern=paste(base_pattern,"_crs.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    rs_freqs<-get.courter.freqs(rs)[,-1]
  }else if(tolower(type) == "parent"){
    rs<-plot.parent.reps(pattern=paste(base_pattern,"_crs.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    rs_freqs<-get.parent.freqs(rs)[,-1]
  }else if(tolower(type) == "morphs"){
    rs<-plot.pc.reps(pattern=paste(base_pattern,"_crs.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    rs_freqs<-get.morph.freqs(rs)[,-1]
  }
  rs_freqs$CourterRS<-gsub(".*crs(\\d)_ncrs\\d.*","\\1",rownames(rs_freqs))
  rs_freqs$NoncourterRS<-gsub(".*crs\\d_ncrs(\\d).*","\\1",rownames(rs_freqs))
  rs_freqs$Courter2NonRS<-as.factor(as.numeric(rs_freqs$CourterRS)/as.numeric(rs_freqs$NoncourterRS))
  rs_freqs<-rbind(rs_freqs[,c(summ_list,"CourterRS","NoncourterRS","Courter2NonRS")],baseline_freqs[,c(summ_list,"CourterRS","NoncourterRS","Courter2NonRS")])
  rm(rs)
  
  #Parent nest survival
  if(tolower(type) == "courter"){
    psurv<-plot.courter.reps(pattern=paste(base_pattern,"_psurv.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    psurv_freqs<-get.courter.freqs(psurv)[,-1]
  }else if(tolower(type) == "parent"){
    psurv<-plot.parent.reps(pattern=paste(base_pattern,"_psurv.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    psurv_freqs<-get.parent.freqs(psurv)[,-1]
  }else if(tolower(type) == "morphs"){
    psurv<-plot.pc.reps(pattern=paste(base_pattern,"_psurv.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    psurv_freqs<-get.morph.freqs(psurv)[,-1]
  }
  psurv_freqs$ParentSurvival<-gsub(".*psurv(\\d.\\d).*","\\1",rownames(psurv_freqs))
  psurv_freqs<-rbind(psurv_freqs[,c(summ_list,"ParentSurvival")],baseline_freqs[,c(summ_list,"ParentSurvival")])
  rm(psurv)
  
  #Non parent nest survival
  if(tolower(type) == "courter"){
    npsurv<-plot.courter.reps(pattern=paste(base_pattern,"_npsurv.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    npsurv_freqs<-get.courter.freqs(npsurv)[,-1]
  }else if(tolower(type) == "parent"){
    npsurv<-plot.parent.reps(pattern=paste(base_pattern,"_npsurv.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    npsurv_freqs<-get.parent.freqs(npsurv)[,-1]
  }else if(tolower(type) == "morphs"){
    npsurv<-plot.pc.reps(pattern=paste(base_pattern,"_npsurv.*_summary.txt",sep=""),path="sensitivity",cols,make.plot=FALSE)
    npsurv_freqs<-get.morph.freqs(npsurv)[,-1]
  }
  npsurv_freqs$NonparentSurvival<-gsub(".*npsurv(\\d.\\d).*","\\1",rownames(npsurv_freqs))
  npsurv_freqs<-rbind(npsurv_freqs[,c(summ_list,"NonparentSurvival")],baseline_freqs[,c(summ_list,"NonparentSurvival")])
  rm(npsurv)
  
  #calc the summary stats
  summary_stats<-do.call(rbind,lapply(list(polygyny_freqs,rs_freqs,psurv_freqs,npsurv_freqs),function(freqs,summ_list){
    output<-lapply(summ_list,function(summ){
      m<-tapply(freqs[,summ],freqs[,ncol(freqs)],mean)
      sem<-tapply(freqs[,summ],freqs[,ncol(freqs)],function(x){ sd(x)/length(x) })
      param_lab<-gsub(paste(".*",substr(base_pattern,2,nchar(base_pattern)),"_(\\w+).*_summary.txt.*",sep=""),"\\1",rownames(freqs)[1])
      output<-data.frame(param_label=param_lab,params=names(m),means=m,sem=as.numeric(sem))
      colnames(output)<-c("param_label","params",paste(summ,"Mean",sep=""),paste(summ,"SEM",sep=""))
      return(output)
    })
    output<-do.call(cbind,output)
    output<-output[,unique(colnames(output))]
    return(output)
  },summ_list=summ_list))
  
  return(summary_stats)
}







