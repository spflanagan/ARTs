---
title: "ARTs notebook"
output: html_notebook
author: "Sarah P. Flanagan"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,out.extra='',fig.pos="H",dpi=200,fig.height = 7,fig.width = 7)
knitr::opts_knit$set(root.dir='../fixedART-results/') #change
source("~/Dropbox (UC Enterprise)/Research/ARTs/R/002_freq_functions.R")
```


# 14 December 2020

I'm worried about going down unnecessary rabbit holes. What do I want to understand about the model that I don't currently understand?
1. when variation exists, what casues one sneaker type to become prevalent?
2. what causes the differences among runs in terms of variation vs no variation?
3. If the only ones that sneak are non-parents, how do any non-courter/parents mate?

For number 1, I think initial frequencies have something to do with it. For number 2, it could be that fitness is too flat aka the differences between the morphs are not exaggerated enough.

The answer to #3 must arise from females exhausting their options searching for courters and randomly mating with a non-courter/parent. Courter/non-parents might sire a nest that fails but they will also be able to sneak fertilizations. ASK SUZANNE: should both non-courters and non-parents be added to the sneakers list? [I can test this assumption by increasing the female search space]

So let's dig into initial frequencies first, then I'll start some more runs with starker differences and possibly with a larger search space for females.

```{r}
courterRS<-get.morph.freqs(plot.pc.reps(pattern="pcu_1locus_nestBinary_courterRSadvantage.*summary.txt",path="single_locus",cols,make.plot=FALSE))
courterRS1<-get.morph.freqs(plot.pc.reps(pattern="pcu_1locus_nestBinary_courterRSadvantage.*summary.txt",path="single_locus",cols,make.plot=FALSE),gen = "first")
```
```{r}
par(mfrow=c(2,1))
bp<-barplot(t(as.matrix(courterRS[,c("FreqNcNp", "FreqCNp", "FreqNcP")])),
        col=cols2[c("NCNP","CNP","NCP")],
        names.arg = gsub("^.*(\\d)_summary.txt.*$","\\1",rownames(courterRS)),
        las=2,
        border=NA)
legend(x=5,y=0.04,bty='n',legend = c("Courter/Non-parent","Non-courter/Parent","Non-courter/Non-parent"),
       col=cols2[c("CNP","NCP","NCNP")],pch=15,xpd = TRUE,ncol=3,cex=1.25)
bp<-barplot(t(as.matrix(courterRS1[,c("CourterFreq", "ParentFreq")]))-0.5,
        col=cols[c("courter","parent")],
        names.arg = gsub("^.*(\\d)_summary.txt.*$","\\1",rownames(courterRS)),
        las=2,beside = TRUE,
        border=NA)
legend(y=.04,x=15,xpd=TRUE,c("courter","parent"),col=cols[c("courter","parent")],
       ncol=2,pch=15,bty='n',cex=1.25)

```

So, what this suggests is that the initial conditions seem to play a role but it doesn't seem to fully explain it. Also, it's odd because when courters start off as more abundant than parents, the non-courter/parent morph is the most successful one, and when parents start off as more frequent the courter/non-parent is the more successful morph (and I've checked it's not a plotting error).

Could thresholds play a role? 

```{r}
par(mfrow=c(3,1))
bp<-barplot(t(as.matrix(courterRS[,c("FreqNcNp", "FreqCNp", "FreqNcP")])),
        col=cols2[c("NCNP","CNP","NCP")],
        names.arg = gsub("^.*(\\d)_summary.txt.*$","\\1",rownames(courterRS)),
        las=2,
        border=NA)
legend(x=5,y=0.04,bty='n',legend = c("Courter/Non-parent","Non-courter/Parent","Non-courter/Non-parent"),
       col=cols2[c("CNP","NCP","NCNP")],pch=15,xpd = TRUE,ncol=3,cex=1.25)
bp<-barplot(t(as.matrix(courterRS1[,c("CourterFreq", "ParentFreq")]))-0.5,
        col=cols[c("courter","parent")],
        names.arg = gsub("^.*(\\d)_summary.txt.*$","\\1",rownames(courterRS)),
        las=2,beside = TRUE,
        border=NA)
legend(y=.04,x=15,xpd=TRUE,c("courter","parent"),col=cols[c("courter","parent")],
       ncol=2,pch=15,bty='n',cex=1.25)
bp<-barplot(t(as.matrix(courterRS1[,c("CourterThresh", "ParentThresh")])),
        col=cols[c("courter","parent")],
        names.arg = gsub("^.*(\\d)_summary.txt.*$","\\1",rownames(courterRS)),
        las=2,beside = TRUE,
        border=NA)
legend(y=1.75,x=15,xpd=TRUE,c("courter","parent"),col=cols[c("courter","parent")],
       ncol=2,pch=15,bty='n',cex=1.25)

```

So thresholds might be related -- noncourter/parents emerge when courters start off above 0.5 but parents have a higher threshold. courter/nonparents emerge when parents start off above 0.5 (most of the time), regardless of thresholds. Hmm this isn't helping make the picture any clearer. 


I think I want to run a few tests:
- random mating
- females always exert a choice (i.e., they don't mate instead of random mating)
- larger RS tradeoffs

Ok, first running the original sets as before but with females not defaulting to random mating and with only random mating. No other parameter differences from what's in the single locus doc and results already.


# 11 December 2020

So following on from yesterday, clearly something wonky is going on if they're all getting exactly the same alleles. 

```{r}
library(gwscaR)
aevcf<-parse.vcf("arts_pop_0_ae.vcf")
crtGT<-do.call(rbind,strsplit(t(aevcf[1,10:ncol(aevcf)]),"/"))
crtGT<-apply(crtGT,2,as.numeric)

prtGT<-do.call(rbind,strsplit(t(aevcf[2,10:ncol(aevcf)]),"/"))
prtGT<-apply(prtGT,2,as.numeric)
```

Just checking -- this is true for both QTLs. 

I'm going to have the program output the tempalleles during initialization. 

Multiple alleles *are* initialized:
Temp alleles: -0.18129 -0.650723 -0.0726133

Temp alleles: -0.987933 0.513364 -0.570933

```{r}
aevcf<-parse.vcf("arts_test_pop_0_ae.vcf")
crtGT<-do.call(rbind,strsplit(t(aevcf[1,10:ncol(aevcf)]),"/"))
crtGT<-apply(crtGT,2,as.numeric)

prtGT<-do.call(rbind,strsplit(t(aevcf[2,10:ncol(aevcf)]),"/"))
prtGT<-apply(prtGT,2,as.numeric)
```

crtGT
-0.18129 
    2000 
table(prtGT)
prtGT
0.513364 
    2000 

So it's only assigning one of them but inconsistently. I'm going to add some outputs just to try to track down what's going on here.
In initializing the individuals, it seems that different alleles are being allocated -- so what's happening? 

Ah I was outputting genotypes in every generation, not just the first one. Let's try this again (with a debug mode incorporated as well). Ok, now the vcf has variety

table(crtGT)
crtGT
0.168514 0.624808 
     978     1022 
table(prtGT)
prtGT
-0.280098  0.251608 
     1026       974 

Ok, so why was I looking into this? Ah yes, because there's apparently no variation in traits at the start based on the summary info.

```{r}
traits<-read.delim("arts_test_traits.txt")
hist(traits$CourtTrait[traits$Gen==0 & traits$Pop==0])

hist(rowSums(crtGT))

```

Ahh, this is because they're all homozygotes, so this is expected. I could output trait values at gen 1 if I wanted too ensure things are mixing properly.

```{r}
traits<-read.delim("arts_test_traits.txt")
hist(traits$CourtTrait[traits$Gen==3 & traits$Pop==0])


```
Ok well this works I think - by generation 3 there are some new combinations

But otherwise I think I can move on?

I'm going to look into:
- check whether all have variation or just some (barplots might not be showing small small values)
I was right to check this, because there are a number of runs that are not obvious in the barplots but do have tiny amounts of variation (prob 1-2 individuals of the sneaker phenotype).



# 10 December 2020

I've fixed a tiny bug from yesterday and am running some tests. One thing that I've done today is added the writing of some debug info to a log file, but this is a teensy bit slow (it's all the reproductive success outputs) and probably not useful -- considering adding a debug flag and having it only output it at that point rather than with --verbose.

In the meantime, I can take a look at the vcf file that's been output.

```{r}
library(gwscaR)
aevcf<-parse.vcf("arts_pop_0_ae.vcf")
crtGT<-do.call(rbind,strsplit(t(aevcf[1,10:ncol(aevcf)]),"/"))
crtGT<-apply(crtGT,2,as.numeric)
```

They're all the same!

# 9 December 2020

The only ones that sneak are non-parents (I wonder if this is the best way to do it?)

```{r}
traits<-read.delim("single_locus/pcu_1locus_nestBinary_courterRSadvantage_5_traits.txt")
summary<-read.delim("single_locus/pcu_1locus_nestBinary_courterRSadvantage_5_summary.txt")

plot(traits$CourtTrait[traits$Gen==0 & traits$Pop==0],
     pch=as.numeric(traits$Sex[traits$Gen==0 & traits$Pop==0]))
```

Somehow we're still not getting any variation in trait values at the start of the population.
```{r}
plot(traits$CourtTrait[traits$Gen==12000 & traits$Pop==0],
     pch=as.numeric(traits$Sex[traits$Gen==12000 & traits$Pop==0]))
```

I guess it's because we have only one locus with its allelic effects? 

```{r}
ae<-read.delim("single_locus/pcu_1locus_nestBinary_courterRSadvantage_5_allelic-effects.txt")
plot(ae$ParentQTL0,type = 'l')
plot(ae$CourterQTL0,type = 'l')
```

So the population average allelic effects change as the population fixes for one morph or the other, unsurprisingly. But why is it only the two values to start with? 

To dive into this I need to adjsut the outputs (put in a debugging output probably). I want basically want the genotypes for all individuals in gen 0 to find out how the alleles are distributed and if that makes sense. I've written this code but need to test it. 


# 7 December 2020

Ok so now I'm not sure if what I'm observing is expected or unexpected. I sort of would have expected sneakers all the time in my other scenarios -- but I guess I have female preferences inherent in the model so that might alter my expectations.  

Things to remind myself of:
- who is allowed to sneak?

Things to investigate:
- how much variation exists in traits at the start and end of the model?
- check whether all have variation or just some (barplots might not be showing small small values)
- what happens with random mating?
- is there a way to calculate expected numbers to be output?
- is there a consistent pattern with starting proportions related to finishing proportions?

# 25 November 2020

So the problem with the lifetime RS counter was that I output the traits after I'd already reset the population, so I've cahnged it to output the info before the population resets in the final generation. 

How do any courter/non-parents have surviving offspring? Is it if the female mates with a courter/parent?
-> So it looks like the female mates once but then there can be sneakers, so courter/non-parents must be senakers (I don't track this info).

Also, somehow males are getting more than their potential RS - ah this must be because of density dependent selection where offspring are assigned to nests proportional to mating success.

All of the parent and courter trait values are the same though -- at the beginnng they are binary and by the end they appear to be fixed. Not sure what's going on there...I think it has to do with the fact that the index of the adult determines which allele they have, so there are equal numbers of both. Perhaps recombination/mutation rate are not high enough? I could let them have a random allele at each locus. -- it turns out this is what I'm doing!



# 12 November 2020

Unsurprisingly in runs with courter/non parents existing at the end, both males and females have that morph. However, they have a LifetimeRS of 0 - so how are they maintained??? Ahh except LifetimeRS is 0 for everyone so this is not a useful metric!

```{r}
traits<-read.delim("single_locus/pcu_1locus_nestBinary_courterRSadvantage_5_traits.txt")
traits0<-traits[which(traits$Pop==0),]
traits0last<-traits0[which(traits0$Gen==12000),]
table(traits0last$Sex[which(traits0last$Courter!=traits0last$Parent)])
traits0last[which(traits0last$Courter!=traits0last$Parent),]
```
```{r}
traits[which(traits$Pop==0 & traits$Individual %in% traits0last$Individual[which(traits0last$Courter!=traits0last$Parent)]),]
```

Compare this to the thresholds?

# 11 November 2020

I thought I'd solved it with the changes that I implmented, but I'm still getting some weird appeaances of the courter/non-parent, which shouldn't be reproducing at all! I want to check a couple things, though:
1. how are the fitnesses calculated?
2. is there a relationship between parent W vs courter W and the emergence of different combinations?
3. are the morph frequencies including females? because that could be a pathway to maintain them, though I wouldn't think so.
4. Which aspects of the intiial conditions seem to be most important in determining outcomes? 
5. will initial generation trait distributions help at all? 

# 5 November 2020

I'm not sure what I've done but I've broken something because now all of the outputs are identical, even with different parameter settings. There seem to be a few possibilities:
1. I've broken the set seed component and randomizer isn't working properly
2. I need to spawn all of these commands in a different way that doesn't start them all at the same time
3. the changes I've made to the initialization isn't working

So a few things I'm trying:
1. using gnu parallel to run the code rather than sending to the background
2. I'll try using time(NULL)*pid(), which should be unique for each run, to set the seed
3. I should do some investigation of what's happening in the first couple of generations -- maybe output individual data for gen 0/1


# 4 November 2020

Yesterday I discovered that my code --  which spawns things using nohup and & -- doesn't necessarily set the seed properly. Somehow multiple runs have the same initial conditions. I should check my C++ code to see what's going on.
-> looking at my code, I'm using a custom function sgenrand(time(0)) which should get around this (it adjusts the seed after it's set as time(0)), but it was within population(), which is probably not the right place for it. So I've moved it to the top of main() in lifecycle.cpp.
-> could also try the suggestions in this thread: https://stackoverflow.com/questions/7617587/is-there-an-alternative-to-using-time-to-seed-a-random-number-generation

I also have realized what's causing the main issue: I randomly assign males to be courter/non-courter and parent/non-parent, and somehow sometimes I wind up with my population being entirely courter/non-parent and non-courter/parent. This means that unless females find a courter, then the population will crash. So this is something funky in my setup which I should probably change. 
-> In the final generation, there's no variation in trait values - but what about at the start?
-> Also I think the way I'm randomizing the alleles is creating problems:

```{c++}
vector<double> tempallele1, tempallele2, tempallele3;
for (j = 0; j < gp.num_alleles; j++) //set up specific alleles.
{
	tempallele1.push_back(randnorm(0, gp.allelic_std_dev/gp.num_qtl));
	tempallele2.push_back(randnorm(0, gp.allelic_std_dev / gp.num_qtl));
	tempallele3.push_back(randnorm(0, gp.allelic_std_dev / gp.num_qtl));
}
for (j = 0; j < gp.carrying_capacity; j++)
{
	if (j < gp.carrying_capacity)
		adults[j].alive = true;
	else
		adults[j].alive = false; 
	adults[j].lifetime_rs = 0;
	for (jj = 0; jj < gp.num_chrom; jj++)
	{
		if (gp.court_trait)
		{
			for (jjj = 0; jjj < gp.qtl_per_chrom[jj]; jjj++)
			{
				adults[j].maternal[jj].courter_ae[jjj] = tempallele1[j%gp.num_alleles];
				adults[j].paternal[jj].courter_ae[jjj] = tempallele1[j%gp.num_alleles];
			}
		}
		if (gp.parent_trait)
		{
			for (jjj = 0; jjj < gp.qtl_per_chrom[jj]; jjj++)
			{
				adults[j].maternal[jj].parent_ae[jjj] = tempallele2[j%gp.num_alleles];
				adults[j].paternal[jj].parent_ae[jjj] = tempallele2[j%gp.num_alleles];
			}
		}
		if (gp.cor_prefs || gp.ind_pref)
		{
			for (jjj = 0; jjj < adults[j].maternal[jj].pref_ae.size(); jjj++)
			{
				adults[j].maternal[jj].pref_ae[jjj] = tempallele3[j%gp.num_alleles];
				adults[j].paternal[jj].pref_ae[jjj] = tempallele3[j%gp.num_alleles];
			}
		}
		for (jjj = 0; jjj < gp.num_markers; jjj++)
		{
			adults[j].maternal[jj].loci[jjj] = j%gp.num_alleles;
			adults[j].paternal[jj].loci[jjj] = j%gp.num_alleles;
		}
	}
```

What this does is create two alleles for each trait and even/odd individuals get each set of alleles. This means that the population is incredibly bimodal in trait values, which is not what we want I think. I want biallelic loci, but I don't want all of the loci to be the same. What if I set up the tempalleles with `gp.numalleles*gp.num_chrom*gp.qtl_per_chrom`? Then each biallelic locus would be different.
Or I could randomly assign one of the tempalleles rather than using j. That might be easier actually- then I'd expect an ~ equal distribution of trait combinations at the start.

# 15 October 2020

For now I'm adding text to each section, which will help me with the narrative structure of the summary and to identify some next steps.

I've now covered the reproductive allocation and nest survival tradeoffs and the supergene proportion - mating system is still a bit elusive on what to show. 
Currently it's got the thresholds for being courter/parent as the x axis but I don't think this is overly useful. 
I think I was using that to try to explain why some sets of runs resulted in courter-parents and others resulted in courters-nonparents.
But thresholds don't seem to explain any patterns - I would guess it's initial frequency.

# 14 October 2020

So I've neglected this analysis for a very long time, and now I'm not quite sure where I am. I downloaded a bunch of files from the supercomputer earlier this year, all of which were reproductive allocation ones. I saved these in oct2019/ to avoid overwriting any in repro_allocation, so they all finished properly. I moved the ones that didn't overwrite using `mv -n`. The ones that would have overwritten the ones in repro_allocation remain in oct2019. All of the files in repro_allocation are 'complete'.

So now I'm re-knitting the doc to evaluate where I'm at. 

The plotting is really  not helpful. I need to change this!

I've turned the summary plots into stacked barplots, which is better for comparing frequencies. 

what do I want to show in the summary doc?
* how do I show the role of mating system?
* do I care about the thresholds?
* are there other runs I should summarize?

I also need to ID next steps, which include at least popgen analyses.


# 2 September 2019

The simulations finished running, so now I'm going to re-evaluate the analysis by looking at the final generations like below.

```{r}
cps_ra<-plot.pc.reps(pattern="^parent-courter_.*_RA_.*_summary.txt",path="repro_allocation",cols="red",make.plot=FALSE)
max_gens<-unlist(lapply(cps_ra,function(dat) return(max(dat$Generation))))
max_gens<-max_gens[max_gens!="-Inf"]
good_files<-unique(gsub("_\\d$","",names(max_gens[max_gens==11999])))
bad_files<-unique(gsub("_\\d$","",names(max_gens[max_gens<11999])))
```

This fixed it, there are 0 bad files! Woo hoo! Now to recompile the document to learn something about the model results.

I'm also putting the 'reproductive allocation' data in the directory repro_allocation/ within fixedARTs-results/.

I need to run more simulations to fill in the patterns (not to mention come up with better ways to present the analyses, hopefully). Started runs with more combos on abacus, job array is 1385398.1-3.

# 19 August 2019

Ok I've put off dealing with this for a while. I've re-created the good_files and bad_files as below and will do a couple things. 
1. Check if it says "Evaluating equilibirum" in the log file. 
   nope
2. Check if it says "Input integer to quit" in the log file. 
  nope
3. Other error messages?

Ok, wait, one of the 'bad_files' actually ran through to equilibrium according to the log file:
parent-courter_supergene_RA_c2_nc2_p0.2_np0.6_1.log shows 11999 generations, but
parent-courter_supergene_RA_c2_nc2_p0.2_np0.6_1_summary.txt.gz only goes to 3899 generations. what?

Let's check the outputting functions in my code (I don't know what would have happened).

I've fixed some of the extinction checking but I don't think this is what's causing the issue. 

The only thing that seems like it could be the explanation would be a space issue? Maybe I run out of space on the supercomputer? Then I would expect the later-in-the-loop parameters to be bad. 

Ok, so first I need to figure out why I'm getting -Inf values in my max_gens. This seems to be due to sensitivity/parent-courter_supergene_RA_c8_nc4_p0.4_np0.6_1_summary.txt.gz_1, which has no rows for Pop 1...it seems the numbering got shifted somehow. Weird. I'll just ignore it then.  

```{r}
cps_ra<-plot.pc.reps(pattern="^parent-courter_.*_RA_.*_summary.txt",path="sensitivity",cols,make.plot=FALSE)
max_gens<-unlist(lapply(cps_ra,function(dat) return(max(dat$Generation))))
max_gens<-max_gens[max_gens!="-Inf"]
good_files<-unique(gsub("_\\d$","",names(max_gens[max_gens==11999])))
bad_files<-unique(gsub("_\\d$","",names(max_gens[max_gens<11999])))

```

```{r}
bad_chars<-data.frame(arch=gsub("sensitivity/parent-courter_(\\w+)_RA.*","\\1",bad_files),
                      cval=gsub(".*_RA_c(.*)_nc.*_p.*_np.*_.*","\\1",bad_files),
                      ncval=gsub(".*_RA_c.*_nc(.*)_p.*_np.*_.*","\\1",bad_files),
                      pval=gsub(".*_RA_c.*_nc.*_p(.*)_np.*_.*","\\1",bad_files),
                      npval=gsub(".*_RA_c.*_nc.*_p.*_np(.*)_\\d+.*","\\1",bad_files),
                      rep=gsub(".*_RA_c.*_nc.*_p.*_np.*_(\\d+).*","\\1",bad_files))

good_chars<-data.frame(arch=gsub("sensitivity/parent-courter_(\\w+)_RA.*","\\1",good_files[grep("RA",good_files)]),
                      cval=gsub(".*_RA_c(.*)_nc.*_p.*_np.*_.*","\\1",good_files[grep("RA",good_files)]),
                      ncval=gsub(".*_RA_c.*_nc(.*)_p.*_np.*_.*","\\1",good_files[grep("RA",good_files)]),
                      pval=gsub(".*_RA_c.*_nc.*_p(.*)_np.*_.*","\\1",good_files[grep("RA",good_files)]),
                      npval=gsub(".*_RA_c.*_nc.*_p.*_np(.*)_\\d+.*","\\1",good_files[grep("RA",good_files)]),
                      rep=gsub(".*_RA_c.*_nc.*_p.*_np.*_(\\d+).*","\\1",good_files[grep("RA",good_files)]))
```

All of these seem the same. So what if the errors about gzip errors are giving me the real information? Nope, that doesn't seem to be an indicator.

Is this happening for the non-supergene ones?

The question in my mind is whether this is a bug or a supercomputer glitch. It seems too frequent to be a supercomputer glitch, but I also cannot figure out what went wrong. 

In the command line, I did `zgrep "11999.*Pop3" *summary.txt.gz > popsizeSearch.txt` and `zgrep "equilibrium" *log > equilibriumSearch.txt` 

```{r}
eq<-read.delim("sensitivity/equilibriumSearch.txt",header = FALSE)
eq$name<-gsub("(.*).log:.*","\\1",eq$V1)
ps<-read.delim("sensitivity/popsizeSearch.txt",header=FALSE)
ps$name<-gsub("(.*)_summary.txt.gz:.*","\\1",ps$V1)
```

The popsize search ones should be the same as the good_files, I expect

```{r}
which(!paste0("sensitivity/",ps$name,"_summary.txt.gz") %in% good_files)
```


....I wonder if it's gzipping ones that are being run?? That's probably it! If I have the gzip in the same script then it needs to be more specific and only gzip the ones it just did. Hopefully this resolves the issue. I'm running it again on the supercomputer to see.

# 22 July 2019

The test run ran without any problems -- all the way through to generation 11999. This does not help me solve the issue. 

# 19 July 2019

Looking at the C++ code, the summary data is output for all initial generations and experimental generations. The only way the number of generations is cut short is through extinction. Equilibrium is only evaluated after all experimental generations. So the only thing I can think of is that this is an issue with running it on the server?? This is a major issue because it's I'm looking at the frequencies in the FINAL generation, and if I'm only seeing intermediate generations then I'm not necessarily seeing the right stuff. Let's take a look at the data again:

```{r setup, echo=FALSE,echo=FALSE,message=FALSE}
library(RColorBrewer)
library(scales)
library(sm)
library(kableExtra)
source("~/Research/ARTs/R/002_freq_functions.R")
cols<-c(courter="#33a02c",parent="#1f78b4",cpref="#b2df8a",ppref="#a6cee3")
cols2<-c(CP='#a1dab4',NCP='#41b6c4',CNP='#2c7fb8',NCNP='#253494')
base_keep_cols<- c("Pop","PopSize","NumMal","NumFem","ParentThresh","ParentFreq","CourterThresh","CourterFreq","FreqNcNp","FreqCNp",
                   "FreqNcP","FreqCP","Courter2NonRS","Parent2NonSurvival")
```

```{r lookingAtGens}
cps_baseline<-plot.pc.reps("^parent-courter_supergene_.*_summary.txt",path="baseline",cols,make.plot=FALSE)
cps_ra<-plot.pc.reps(pattern="^parent-courter_supergene_RA_.*_summary.txt",path="sensitivity",cols,make.plot=FALSE)
max_gens<-c(unlist(lapply(cps_baseline,function(dat) return(max(dat$Generation)))),
            unlist(lapply(cps_ra,function(dat) return(max(dat$Generation)))))
hist(max_gens)  
```

`r length(max_gens[max_gens<11999])` of `r length(max_gens)` runs have fewer than the expected number of generations. Running `grep "crashed" parent-courter_supergene_RA*log` results in no output. 

The only error messages in the server log files are gzip errors (I'm guessing it tried to run gzip on files that had already been gzipped?). But those were all run starting May 27 or 28...so maybe there's an informative batch effect I can deduce?

```{r}
good_files<-unique(gsub("_\\d$","",names(max_gens[max_gens==11999])))
bad_files<-unique(gsub("_\\d$","",names(max_gens[max_gens<11999])))
file.info(good_files)$mtime
file.info(bad_files)$mtime
```

Ok, so there doesn't seem to be a pattern with when they were created. 

Are the only ones with variation the ones that have finished early?

```{r}
cps_ra_freqs<-get.morph.freqs(cps_ra)
cps_ra_freqs$Parent2NonSurvival<-as.numeric(gsub(".*_p(\\d.\\d).*","\\1",rownames(cps_ra_freqs)))/as.numeric(gsub(".*np(\\d.\\d).*","\\1",rownames(cps_ra_freqs)))
cps_ra_freqs$Courter2NonRS<-as.numeric(gsub(".*_c(\\d).*","\\1",rownames(cps_ra_freqs)))/as.numeric(gsub(".*nc(\\d).*","\\1",rownames(cps_ra_freqs)))

plot_2vars_summary(cps_ra_freqs[cps_ra_freqs$Generation==11999,],"Courter2NonRS","Parent2NonSurvival",mar=c(5.1,4.1,4.1,2.1))

```

Ok, so some variation does still happen. Are there any other indications? Perhaps the parameter values?

```{r}
plot_2vars_summary(cps_ra_freqs[cps_ra_freqs$Generation<11999,],"Courter2NonRS","Parent2NonSurvival",mar=c(5.1,4.1,4.1,2.1)) #this doesn't help
# extract all parameter info
cps_ra_freqs$C<-as.numeric(gsub(".*RA_c(\\d)_.*","\\1",rownames(cps_ra_freqs)))
cps_ra_freqs$NC<-as.numeric(gsub(".*_nc(\\d)_.*","\\1",rownames(cps_ra_freqs)))
cps_ra_freqs$P<-as.numeric(gsub(".*_p(\\d.\\d)_.*","\\1",rownames(cps_ra_freqs)))
cps_ra_freqs$NP<-as.numeric(gsub(".*_np(\\d.\\d)_.*","\\1",rownames(cps_ra_freqs)))
cps_ra_freqs$rep<-as.numeric(gsub(".*_(\\d)_summary.*","\\1",rownames(cps_ra_freqs)))
cps_ra_freqs$Problem<-FALSE
cps_ra_freqs$Problem[cps_ra_freqs$Generation<11999]<-TRUE

tapply(cps_ra_freqs$rep,cps_ra_freqs$Problem,summary)
tapply(cps_ra_freqs$C,cps_ra_freqs$Problem,summary)
tapply(cps_ra_freqs$NC,cps_ra_freqs$Problem,summary)
tapply(cps_ra_freqs$P,cps_ra_freqs$Problem,summary)
tapply(cps_ra_freqs$NP,cps_ra_freqs$Problem,summary)

```

None of these seem to factor into whether it's a problem child or not. What else could it be??? Stochasticity? Time of day?

```{r}
file.info(good_files)$mtime
file.info(bad_files)$mtime
```

Well, these are the times when they were downloaded, not the times they were run, and I've already deleted the files off the server. I have no idea what could be causing this issue!!

I'm going to try running one of the bad combos on my local computer, and next time I should check to see if the same thing is happening with the other genetic architectures.


# 18 July 2019

I'm transitioning from my paper notebook to this online notebook to improve reproducibility and better track my work and progress.

So far with the ARTs model I've been testing how sensitive it is to reproductive parameters -- the relative reproductive allocation for courters vs noncourters and the nest survival rates for parents vs nonparents. 

![results for QTLs in a supergene]("../figs/unnamed-chunk-11-1.png")

Looking at these results, a few things stand out to me:

* The points at different frequencies are hard to see
* The diamonds and triangles seem to be different sizes, which throws off some amount of inference
* There don't seem to be overly consistent patterns! 
* I've apparently kept my runs to a particular part of parameter space
* I should label my chunks in the Rmd so that the figures get useful names

I recently added the output of allelic effects to my code, hoping that doing so might shed some light on what determines the outcome of each run, because as I noted on 7 May 2019, the thresholds alone are not useful. So FIRST I'm going to dive into the allelic effects, focusing on those results for QTLs in a supergene. Taking the code to load and create that figure from 105_sensitivity-analysis-summary.Rmd:

First we'll read in the data from the relevant runs -- focusing only on the QTLs + supergenes that are newest, so those labelled with "RA" (plus the baseline):

```{r RA_basecols}
base_keep_cols<- c("Pop","PopSize","NumMal","NumFem","ParentThresh","ParentFreq","CourterThresh","CourterFreq","FreqNcNp","FreqCNp",
                   "FreqNcP","FreqCP","Courter2NonRS","Parent2NonSurvival")
```
```{r setup, echo=FALSE,echo=FALSE,message=FALSE}
library(RColorBrewer)
library(scales)
library(sm)
library(kableExtra)
source("~/Research/ARTs/R/002_freq_functions.R")
cols<-c(courter="#33a02c",parent="#1f78b4",cpref="#b2df8a",ppref="#a6cee3")
cols2<-c(CP='#a1dab4',NCP='#41b6c4',CNP='#2c7fb8',NCNP='#253494')
```

```{r readBaseline_Supergene}
cps_baseline_freqs<-get.morph.freqs(plot.pc.reps("^parent-courter_supergene_.*_summary.txt",path="baseline",cols,make.plot=FALSE))
cps_baseline_freqs$Courter2NonRS<-8/4
cps_baseline_freqs$Parent2NonSurvival<-0.9/0.1
```

```{r readNonParentalRA_Supergene}
cps_ra_freqs<-get.morph.freqs(plot.pc.reps(pattern="^parent-courter_supergene_RA_.*_summary.txt",path="sensitivity",cols,make.plot=FALSE))
cps_ra_freqs$Parent2NonSurvival<-as.numeric(gsub(".*_p(\\d.\\d).*","\\1",rownames(cps_ra_freqs)))/as.numeric(gsub(".*np(\\d.\\d).*","\\1",rownames(cps_ra_freqs)))
cps_ra_freqs$Courter2NonRS<-as.numeric(gsub(".*_c(\\d).*","\\1",rownames(cps_ra_freqs)))/as.numeric(gsub(".*nc(\\d).*","\\1",rownames(cps_ra_freqs)))
#MODIFIED FROM SOURCE SCRIPT BECAUSE I'M NOT USING THE OTHER RUNS
cps_all_freqs<-rbind(cps_ra_freqs[,base_keep_cols],cps_baseline_freqs[,base_keep_cols])
```


Now we can make a summary plot!

```{r RA_Summary}
plot_2vars_summary(cps_all_freqs,"Courter2NonRS","Parent2NonSurvival",mar=c(5.1,4.1,4.1,2.1))
```

So an interesting run seems to be when the reproductive allocation is 2 courter : 1 non-courter and 0.67 parent : non-parent

```{r exploreRA}
cps_all_freqs[cps_all_freqs$Courter2NonRS==2 & round(cps_all_freqs$Parent2NonSurvival,2)==0.67,]
```

This set of parameters contains one run that apparently didn't go well, `r rownames(cps_all_freqs[is.na(cps_all_freqs$PopSize),])`. Intriguingly, it's just that first population and not the other populations. It looks like that is the only population that could not reach an equilibrium -- it only had a population size of 991 as well. So I need to update the code to include in the summary non-equilibrium pops as well, perhaps...or this is the better choice? Do I actually not output the information or is it simply not read by the summary functions? Either way, this is what the 'true' graph should look like:

```{r RA_SummaryNArm}
plot_2vars_summary(cps_all_freqs[!is.na(cps_all_freqs$PopSize),],"Courter2NonRS","Parent2NonSurvival",mar=c(5.1,4.1,4.1,2.1))
```

Before moving forward, I'd like to investigate this non-equilibrium issue, so let's read in that summary file.

```{r RAc8nc5p4np6, warning=FALSE}
dat<-read.delim(gzfile(gsub("_1$","",rownames(cps_all_freqs[is.na(cps_all_freqs$PopSize),]))),header = TRUE,sep='\t')
nrow(dat[dat$Pop=="Pop0",])
nrow(dat[dat$Pop=="Pop1",])
tapply(dat$Generation,dat$Pop,max)
```


Ok, so that's weird. Obviously there's a bug in the code where the population data doesn't get output -- maybe for Pop 3 when it's reached equilibrium? Also, I feel I should keep running it until equilibrium is reached for each population. Looking at the C++ code doesn't reveal anything immediately obvious, so let's take a look at the rows around this error.

```{r}
weirdn<-which(!dat$Pop %in% c("Pop0","Pop1","Pop2","Pop3"))
dat[(weirdn-5):(weirdn+5),]
```

What happened at generations 1956 - 1963?? This is really strange because it should have been during the initial generations (10000, checked using `zless parent-courter_supergene_RA_c8_nc4_p0.4_np0.6_1_parameters.txt.gz`), unless I'm mis-labelling the experimental ones. Let's look at the distribution of generations

```{r}
hist(dat$Generation,seq(0,6500,1))
```

The giant black block suggests that they're all respresented the same number of times, which means that this particular run stopped within the initial generations, which shouldn't happen. 

Let me see what one that behaves 'normally' looks like:

```{r}
testdat<-read.delim(gzfile(gsub("_\\d$","",rownames(cps_all_freqs[which(is.na(cps_all_freqs$PopSize))+5,]))),header = TRUE,sep='\t')
tapply(testdat$Generation,testdat$Pop,max)
```

Ok, so this one doesn't have weird entries but it does seem to have stopped during the initial generations, unless I'm misunderstanding my output. The log file also tracks it as going to generation 11999, but it's not in the summary output -- equilibrium is reached, perhaps that's the issue? I'm thinking I need to revisit my program before moving forward, because this is an important component of how I'm evaluating this output.

