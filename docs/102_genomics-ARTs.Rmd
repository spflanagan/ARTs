---
title: "Investigating the genomics of alternative reproductive tactics"
author: "Sarah P. Flanagan"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::pdf_document2:
    fig_caption: yes
    keep_tex: yes
    number_sections: no
    template: manuscript.latex
    toc: yes
    toc_depth: 2
spacing: singlespacing
fontsize: 11pt
capsize: normalsize
documentclass: article
footerdate: yes
graphics: yes
csl: evolution.csl
editor_options:
  chunk_output_type: console
---

The purpose of this model is to understand how genetic architectures of alternative reproductive tactics impact their maintenance in populations. I'm using an individual-based simulation model with different selection scenarios, types of alternative tactics, and genetic architectures (genome-wide additive genetic variance, supergenes, expression networks). To explore the parameter space, I'm also using a mathematical model without the genetic architectures to identify regions of parameter space where we expect multiple morphs to be maintained. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,out.extra='',fig.pos="H",dpi=200,fig.height = 7,fig.width = 7)
knitr::opts_knit$set(root.dir='../results/') #change

```
```{r opts, echo = FALSE}
library(knitr)
knitr::opts_chunk$set(
  fig.path = "figs/"
)
```
```{r librarysetup, echo=FALSE,echo=FALSE,message=FALSE}
library(RColorBrewer)
library(scales)
library(sm)
library(kableExtra)
library(plotly)
library(dplyr)
library(vegan)
library(tidyr)
library(vcfR)
source("../R/003_genomic_summaries.R")
source("../R/002_freq_functions.R")

source("../morph_predictions/check_freqs.R")
source("../morph_predictions/morph_gens_ns.R")

cols<-c(courter="#33a02c",parent="#1f78b4",cpref="#b2df8a",ppref="#a6cee3")
cols2<-c(CP='#d7191c',NCP='#fdae61',CNP='#abd9e9',NCNP='#2c7bb6')
```
```{r baseCols}
base_keep_cols<- c("Pop","PopSize","NumMal","NumFem","ParentThresh","ParentFreq","CourterThresh","CourterFreq","FreqNcNp","FreqCNp",
                   "FreqNcP","FreqCP","Courter2NonRS","Parent2NonSurvival")
poly_keep_cols<- c("Pop","PopSize","NumMal","NumFem","ParentThresh","ParentFreq","CourterThresh","CourterFreq","FreqNcNp","FreqCNp",
                    "FreqNcP","FreqCP","Polygyny")

```

## The goal

We want to be able to link empirical data to our model predictions. To do that, we want to be able to look at patterns of genetic variation genome-wide. 

```{r}
path<-"../results/"#"/mnt/BigData/fixedART-results/qtls/"
vcfname<-paste0(path,"highDiversity_qtls_q8_c4_1_pop_2.vcf")

ex1<-get.morph.freqs(plot.pc.reps(pattern="highDiversity_qtls_q8_c4_1_summary.txt",path=path,cols,make.plot=FALSE))

vcf1<-read.vcfR(vcfname)
```

```{r}
qtl_info<-read.delim(paste0(path,"highDiversity_qtls_q8_c4_1_qtlinfo.txt"))
qtl_locs<-which(vcf1@fix[,"ID"] %in% qtl_info[1,])
```

It would be great to calculate Fsts between the different groups, including males and females. 

```{r}
mf_pop<-as.factor(gsub("^(\\w{3}).*$","\\1",colnames(vcf1@gt)[-1]))
mt_pop<-as.factor(gsub("^(\\w{3}).*_(\\w+)$","\\2",colnames(vcf1@gt)[-1]))
mt_mal<-factor(mt_pop[mf_pop=="MAL"])
```

```{r}
mf_diff<-genetic_diff(vcf1, pops = mf_pop, method = 'nei')
plot(mf_diff$Gprimest,pch=19,
     xlab="Locus",
     ylab="Gst between males and females")
points(qtl_locs, mf_diff$Gprimest[qtl_locs],cex=2,col="red",pch=8)
```

```{r}
hist(mf_diff$Gprimest)
lapply(mf_diff$Gprimest[qtl_locs],function(d){ abline( v = d) })
```


```{r}
mt_diff<-genetic_diff(vcf1, pops = mt_pop, method = 'nei')
plot(mt_diff$Gst,pch=19,
     xlab="Locus",
     ylab="Gst between types, including female preferences")
points(qtl_locs, mt_diff$Gst[qtl_locs],cex=2,col="red",pch=8)
```

```{r}
mal_vcf<-vcf1[,c(1,which(mf_pop=="MAL")+1)]
mtm_diff<-genetic_diff(mal_vcf, pops = mt_mal, method = 'nei')
plot(mtm_diff$Gprimest,pch=19,
     xlab="Locus",
     ylab="Gst' between male types")
points(qtl_locs, mtm_diff$Gprimest[qtl_locs],cex=2,col="red",pch=8)
abline(h=mean(mtm_diff$Gprimest, na.rm = TRUE),col="grey",lty=2)
abline(h=median(mtm_diff$Gprimest, na.rm = TRUE),col="grey",lty=3)
```


```{r}
hist(mtm_diff$Gprimest)
lapply(mtm_diff$Gprimest[qtl_locs],function(d){ abline( v = d) })
```



So this works well for visualising, but in this particular example the QTLs aren't outliers. I would like to find a way to summarize this across runs. 

If I use a similar approach as I did for my gwsca model, I want to find peaks and identify if a QTL exists in the peak. In my previous model, I hard-coded that in C++, but I'm feeling lazy and would prefer to just do it in R at this point. So I found some code online that should find peaks for me.

```{r}
# From https://stats.stackexchange.com/questions/22974/how-to-find-local-peaks-valleys-in-a-series-of-data
# answer/code by stas g, posted 5 Aug 2015, accessed 6 Dec 2021
find_peaks <- function (x, m = 3){
  
  # remove NAs (my modification)
  x<-x[!is.na(x)]
    shape <- diff(sign(diff(x, na.pad = FALSE)))
    pks <- sapply(which(shape < 0), FUN = function(i){
       z <- i - m + 1
       z <- ifelse(z > 0, z, 1)
       w <- i + m + 1
       w <- ifelse(w < length(x), w, length(x))
       if(all(x[c(z : i, (i + 2) : w)] <= x[i + 1])) return(i + 1) else return(numeric(0))
    })
     pks <- unlist(pks)
     pks
}
```

```{r}
mtm_diff$Gprimest[is.na(mtm_diff$Gprimest)]<-0
peaks<-find_peaks(mtm_diff$Gprimest,m = 50)
plot(mtm_diff$Gprimest,
     type="l",
     xlab="Locus",
     ylab="Gst' between male types")
points(qtl_locs, mtm_diff$Gprimest[qtl_locs],cex=2,col="red",pch=8)
points(peaks,mtm_diff$Gprimest[peaks],cex=2,col="purple",pch=6)
```

```{r}
Gcutoff<-qnorm(p = 0.99,
               mean=mean(mtm_diff$Gprimest),
               sd = sd(mtm_diff$Gprimest))
sigPeaks<-peaks[which(mtm_diff$Gprimest[peaks] >= Gcutoff)]
QTLsInPeaks<-sapply(qtl_locs,function(q,peaks){
  n<-sapply(peaks, function (p){
    if(p-50 <= q & p + 50 >= q){
      return(TRUE)
    }  else{
      return(FALSE)
    }
  })
  return(sum(n))
}, peaks=sigPeaks)
```


## Summarizing multiple files

```{r}
get_summary<-function(vcfname){
  
  # get the data
  vcf1<-read.vcfR(vcfname)
  qtl_info<-read.delim(gsub("_pop_\\d+\\.vcf","_qtlinfo\\.txt",vcfname))  
  qtl_locs<-which(vcf1@fix[,"ID"] %in% qtl_info[1,])
  
  # defining populations
  mf_pop<-as.factor(gsub("^(\\w{3}).*$","\\1",colnames(vcf1@gt)[-1]))
  mt_pop<-as.factor(gsub("^(\\w{3}).*_(\\w+)$","\\2",colnames(vcf1@gt)[-1]))
  mt_mal<-factor(mt_pop[mf_pop=="MAL"])
  
  # Fsts
  mf_diff<-genetic_diff(vcf1, pops = mf_pop, method = 'nei')
  #mt_diff<-genetic_diff(vcf1, pops = mt_pop, method = 'nei')
  mal_vcf<-vcf1[,c(1,which(mf_pop=="MAL")+1)]
  mtm_diff<-genetic_diff(mal_vcf, pops = mt_mal, method = 'nei')
  mtm_diff$Gprimest[is.na(mtm_diff$Gprimest)]<-0

  # find the peaks - mf
  mf_peaks<-find_peaks(mf_diff$Gprimest,m = 50)
  
  Gcutoff<-qnorm(p = 0.99,
                 mean=mean(mf_diff$Gprimest, na.rm=TRUE),
                 sd = sd(mf_diff$Gprimest, na.rm=TRUE))
  mf_sigPeaks<-mf_peaks[which(mf_diff$Gprimest[mf_peaks] >= Gcutoff)]
  if(length(mf_sigPeaks) > 0){
     mf_QTLsInPeaks<-sapply(qtl_locs,function(q,peaks){
        n<-sapply(peaks, function (p){
          if(p-50 <= q & p + 50 >= q){
            return(TRUE)
          }  else{
            return(FALSE)
          }
      })
      return(sum(n))
    }, peaks=mf_sigPeaks)
  } else{
    mf_sigPeaks<-0
    mf_QTLsInPeaks<-0
  }
 
  
  # peaks - mm
  mtm_peaks<-find_peaks(mtm_diff$Gprimest,m = 50)
  
  Gcutoff<-qnorm(p = 0.99,
                 mean=mean(mtm_diff$Gprimest, na.rm=TRUE),
                 sd = sd(mtm_diff$Gprimest, na.rm=TRUE))
  mtm_sigPeaks<-mtm_peaks[which(mtm_diff$Gprimest[mtm_peaks] >= Gcutoff)]
  if(length(mtm_sigPeaks) > 0){
    mtm_QTLsInPeaks<-sapply(qtl_locs,function(q,peaks){
      n<-sapply(peaks, function (p){
        if(p-50 <= q & p + 50 >= q){
          return(TRUE)
        }  else{
          return(FALSE)
        }
      })
      return(sum(n))
    }, peaks=mtm_sigPeaks)
  } else{
    mtm_sigPeaks<-0
    mtm_QTLsInPeaks<-0
  }

  
  # return the relevant data
  simSum<-data.frame(
    sim = vcfname,
    nChrom = as.numeric(gsub("^.*_c(\\d+).*$","\\1",vcfname)),
    nQTLS = length(qtl_locs),
    # Summaries of the population
    propMale = length(which(mf_pop=="MAL"))/length(mf_pop),
    propP = length(which(mt_mal=="P"))/length(mt_mal),
    propCP = length(which(mt_mal=="CP"))/length(mt_mal),
    propC = length(which(mt_mal=="C"))/length(mt_mal),
    propN = length(which(mt_mal=="NON"))/length(mt_mal),
    propPref0 =  length(which(mt_pop=="pref0"))/length(grep("pref",mt_pop)),
    # Heterozygosity genomewide
    gHtMean = mean(mf_diff$Ht, na.rm=TRUE),
    gHtMedian = median(mf_diff$Ht, na.rm=TRUE),
    gHtVar = var(mf_diff$Ht, na.rm=TRUE),
    qHtMean = mean(mf_diff$Ht[qtl_locs], na.rm=TRUE),
    qHtMedian = median(mf_diff$Ht[qtl_locs], na.rm=TRUE),
    qHtVar = var(mf_diff$Ht[qtl_locs], na.rm=TRUE),
    # Gprime male-male
    gGpMeanMM = mean(mtm_diff$Gprimest, na.rm=TRUE),
    gGpMedianMM = median(mtm_diff$Gprimest, na.rm=TRUE),
    gGpVarMM = var(mtm_diff$Gprimest, na.rm=TRUE),
    qGpMeanMM = mean(mtm_diff$Gprimest[qtl_locs], na.rm=TRUE),
    qGpMedianMM = median(mtm_diff$Gprimest[qtl_locs], na.rm=TRUE),
    qGpVarMM = var(mtm_diff$Gprimest[qtl_locs], na.rm=TRUE),
    # peaks
    nPeaksMM = length(mtm_peaks),
    nSigPeaksMM = length(mtm_sigPeaks),
    propQTLsInPeaksMM = length(mtm_QTLsInPeaks[mtm_QTLsInPeaks > 0])/length(mtm_QTLsInPeaks),
    # Gprime female-male
    gGpMeanMF = mean(mf_diff$Gprimest, na.rm=TRUE),
    gGpMedianMF = median(mf_diff$Gprimest, na.rm=TRUE),
    gGpVarMF = var(mf_diff$Gprimest, na.rm=TRUE),
    qGpMeanMF = mean(mf_diff$Gprimest[qtl_locs], na.rm=TRUE),
    qGpMedianMF = median(mf_diff$Gprimest[qtl_locs], na.rm=TRUE),
    qGpVarMF = var(mf_diff$Gprimest[qtl_locs], na.rm=TRUE),
    # peaks
    nPeaksMF = length(mf_peaks),
    nSigPeaksMF = length(mf_sigPeaks),
    propQTLsInPeaksMF = length(mf_QTLsInPeaks[mf_QTLsInPeaks > 0])/length(mf_QTLsInPeaks)
  )
  
  return(simSum)
}
```




```{r runQTLs, eval=TRUE}
qtl_outliers<-dplyr::bind_rows(lapply(
  list.files(path="/mnt/BigData/fixedART-results/qtls", 
             pattern = ".*highDiversity_qtls_monogamy_nm.*.vcf",
             full.names = TRUE),
  get_summary))
write.csv(qtl_outliers,"qtl_outliers.csv",quote=FALSE,row.names = FALSE)

```



```{r runSupergenes,eval=TRUE}
path <- "/mnt/BigData/fixedART-results/supergene/"
supergene_outliers<-dplyr::bind_rows(lapply(
  list.files(pattern=".*highDiversity.*monogamy_nm*.vcf",
             path= path, 
             full.names = TRUE),
  get_summary,
  path = path))
write.csv(supergene_outliers,"supergene_outliers.csv",quote=FALSE,row.names = FALSE)

```



```{r}
qtl_outliers<-read.csv("qtl_outliers.csv")
supergene_outliers<-read.csv("supergene_outliers.csv")
```









