---
title: "A supplement to: Genetic architecture of alternative reproductive tactics impacts which morphs are maintained under balancing selection"
output:
  bookdown::pdf_document2:
    fig_caption: yes
    keep_tex: yes
    number_sections: no
    toc: no
    includes:
      in_header: supplement_preamble.sty
bibliography: references.bib
capsize: normalsize
documentclass: article
editor_options:
  chunk_output_type: console
  markdown:
    wrap: 72
fontsize: 11pt
preprint: no
mainfont: roboto
geometry: margin=2.5cm
papersize: a4
---

```{r, include=FALSE}
remove_author <- function(x) {
  # identify empty author line
  i <- grep("^\\\\author\\{\\}$", x)
  # be sure it is the one pandoc inserts
  if(length(i) != 0 && grepl('^\\\\date\\{', x[i+1])) x <- x[-i]
  x
}
options(bookdown.post.latex = remove_author)
```

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = FALSE,out.extra='',fig.pos="H",dpi=200,fig.height = 7,fig.width = 7)
knitr::opts_knit$set(root.dir='../results/') #change

```

```{r opts, echo = FALSE, warning=FALSE}
library(knitr)
knitr::opts_chunk$set(
  fig.path = "../figs/"
)
```

```{r librarysetup, echo=FALSE,echo=FALSE,message=FALSE, warning=FALSE}
library(RColorBrewer)
library(scales)
library(sm)
library(kableExtra)
library(plotly)
library(dplyr)
library(vegan)
library(tidyr)
library(vcfR)
tmp<-sapply(list.files(path="../../spfTools/R/",full.names = TRUE),source)
source("../R/002_freq_functions.R")

source("../morph_predictions/check_freqs.R")
source("../morph_predictions/morph_gens_ns.R")

source("../R/formatting.R")
```
```{r}
final_freqs<-read.csv("../results/morph_freqs_summary.csv")
final_freqs$rep<-gsub("^.*Diversity_(.*)_pheno.csv","\\1",final_freqs$file)

```

## Supplemental figure 1

```{r getMathResults}
results<-readRDS("../morph_predictions/morph_results_10000_equalStart.RDS")
results$diversity<-vegan::diversity(round(results[,c("CP","CN","NP","NN")],4))
```

```{r MakeMathParams, fig.cap="Contour plots showing the diversity of the populations given equal initial starting frequencies of all four morphs, the relative reproductive investments (x-axis), sperm competition coefficients (y-axis), and number of sneakers allowed per nest (1 through 5, plots going from top to bottom).", fig.width=4, fig.height=6.5, warning=FALSE,message=FALSE, eval=FALSE, include=FALSE}


contours<-by(results, results$num_sneak, function(sub_calcs){
  
  
  data_wide<-tidyr::spread(
    sub_calcs[,c("r","c","diversity")],
    r,
    diversity
  )
  rownames(data_wide)<-data_wide[,1]
  data_wide<-data_wide[,-1]
  
  fig <- plot_ly(
    x = as.numeric(colnames(data_wide)), 
    y = as.numeric(rownames(data_wide)), 
    z = as.matrix(data_wide), 
    type = "contour",
    width = 450, height = 650
  )
  # add axis labels
  x<-list(title="r")
  y<-list(title="c")
  fig <- fig %>% layout(xaxis=x,yaxis=y)
  # add label to contour names
  fig <- fig %>% colorbar(title = "Diversity")
  # plot
  return(fig)
})


multi_fig <- subplot(contours, nrows = 5, shareY = TRUE, shareX = TRUE)

multi_fig %>% layout(autosize = F) 
```

```{r mathParams, fig.cap="Contour plots showing the diversity of the populations given equal initial starting frequencies of all four morphs, the relative reproductive investments (x-axis), sperm competition coefficients (y-axis), and number of sneakers allowed per nest (1 through 5, plots going from top to bottom).", out.width="200%"}
knitr::include_graphics("../figs/mathParams.png")
```

## Impacts of mating system on the model {#mating-system-results}

We tested the sensitivity of the single-locus model to the strict assumptions of the monogamous mating system. In all models, females were restricted to mate with a single male. First, we relaxed the constraint that females failed to mate if no acceptable male was chosen, and instead allowed females deposit their eggs with a randomly-selected unmated
male in the population should they fail to find a preferred mate
('monogamy + random'). Next we allowed males to be chosen by multiple females, with females who failed to find a preferred mate not being able to produce offspring ('polygyny'). Finally, we allowed males to be chosen y multiple females but allowed females to mate with a randomly-selected unmated male in the
population should they fail to find a preferred mate ('polygyny + random'). 

As expected, in the low diversity parameter space, the majority of
simulations resulted in fixation or near-fixation of the courter/parent
morph, regardless of mating system (Fig. \@ref(fig:MatingTypesFig)). A more surprising result was the
inconsistency of results from the mating systems within the the high
diversity parameter space. Only the case most similar to the
mathematical model -- monogamy -- resulted in
polymorphism, with the courter/parent morph coexisting with either the
non-courter/parent or the non-courter/non-parent morph (Fig.
\@ref(fig:MatingTypesFig)). Both polygyny and 'polygyny + random' resulted in the fixation of the
courter/parent morph, and 'monogamy + random' resulted in the fixation of the
non-courter/parent morph in every case. These results can be explained
by the nature of density-dependent survival in the individual-based
model that are not consistent with the mathematical model; in the
simulation model, offspring are created in proportion to the surviving
offspring after mating has occurred, increasing the males' reproductive
success above their specified reproductive investments. This
proportional survival allows males to escape the costs and increase
their reproductive success beyond what is possible in the mathematical
model. Random mating if non-preferred males are unable to be found also
enables non-courter/parents to have increased reproductive success
compared the the mathematical model predictions, which is why they are
fixed in the monogamy case. If stricter costs on courting males are
imposed, specifying $r=0.25$, meaning that $r_{courter}=2$ and
$r_{non-courter}=8$, the scenarios without random mating do result in
the maintenance of 2 or 3 morphs in most cases for both monogamy and
polygyny (Fig. \@ref(fig:MatingTypesFig)), as expected.

```{r MatingTypesFig, fig.cap="The frequencies of morphs in the final generation of simulation runs a single gene underlying each trait, with parameters expected to yield low diversity (top row), high diversity (centre row), and high diversity with stronger costs on courter reproductive success (bottom row). The frequency of the courter/parent morph in the final generation is printed on top of each bar. In 'monogamy' cases, the males were constrained to only accept eggs from one female in a single clutch, whereas under 'polygyny' males could mate with multiple females. In both cases females mated once. Parameter settings lablled with 'nm' were runs where females did not mate if they could not find a suitable mate (i.e., if no courters were available). Within each parameter set, the numbers below the bars identify sets of simulation runs that were initiated with identical starting conditions."}



par(mfrow=c(3,4),oma=c(3,3,4,1),mar=c(3,1,4,1),xpd=TRUE)

# Low diversity
lowDiv<-get.morph.freqs(plot.pc.reps(pattern="lowDiversity.*summary.txt",path="single_locus",cols,make.plot=FALSE))
var_patts<-unique(gsub(".*lowDiversity_(.*)_\\d_summary.txt_\\d","\\1",rownames(lowDiv)))
var_patts<-grep("v0",grep("RM", var_patts, invert=TRUE, value=TRUE), invert=TRUE, value=TRUE)
varDat<-lapply(var_patts,function(pattern){
  dat<-lowDiv[grep(paste0(pattern,"_\\d"),rownames(lowDiv)),]
  bp<-barplot(t(as.matrix(dat[,c("FreqNcNp", "FreqCNp", "FreqNcP", "FreqCP")])),
        col=cols2[c("NCNP","CNP","NCP","CP")],
        names.arg =gsub("^.*(\\d)_summary.txt.*$","\\1",rownames(dat)),
        las=2,
        border=NA,
        main=pattern)
  text(x=bp,y=0.5,srt=90,labels = dat$FreqCP)

  return(dat)
})

# High diversity
highDiv<-get.morph.freqs(plot.pc.reps(pattern="highDiversity_.*summary.txt",path="single_locus",cols,make.plot=FALSE))
var_patts<-unique(gsub(".*highDiversity_(.*)_\\d_summary.txt_\\d","\\1",rownames(highDiv)))
var_patts<-grep("v0",grep("RM", var_patts, invert=TRUE, value=TRUE), invert=TRUE, value=TRUE)

varDat<-lapply(var_patts,function(pattern){
  dat<-highDiv[grep(paste0(pattern,"_\\d"),rownames(highDiv)),]
  bp<-barplot(t(as.matrix(dat[,c("FreqNcNp", "FreqCNp", "FreqNcP", "FreqCP")])),
        col=cols2[c("NCNP","CNP","NCP","CP")],
        names.arg =gsub("^.*(\\d)_summary.txt.*$","\\1",rownames(dat)),
        las=2,
        border=NA,
        main="")
  text(x=bp,y=0.5,srt=90,labels = dat$FreqCP)

  return(dat)
})

# Strict High Diversity
highDiv<-get.morph.freqs(plot.pc.reps(pattern="highDiversityStrict.*summary.txt",path="single_locus",cols,make.plot=FALSE))
var_patts<-unique(gsub(".*highDiversityStrict_(.*)_\\d_summary.txt_\\d","\\1",rownames(highDiv)))
var_patts<-grep("v0",grep("RM", var_patts, invert=TRUE, value=TRUE), invert=TRUE, value=TRUE)


varDat<-lapply(var_patts,function(pattern){
  dat<-highDiv[grep(paste0(pattern,"_\\d"),rownames(highDiv)),]
  bp<-barplot(t(as.matrix(dat[,c("FreqNcNp", "FreqCNp", "FreqNcP", "FreqCP")])),
        col=cols2[c("NCNP","CNP","NCP","CP")],
        names.arg =gsub("^.*(\\d)_summary.txt.*$","\\1",rownames(dat)),
        las=2,
        border=NA,
        main="")
  text(x=bp,y=0.5,srt=90,labels = dat$FreqCP)

  return(dat)
})

# outer legend
par(fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), mar=c(0, 0, 0, 0), new=TRUE)
plot(0,0, type='n', bty='n', xaxt='n', yaxt='n')
legend("top",bty='n',legend = c("Courter/Parent","Courter/Non-parent","Non-courter/Parent","Non-courter/Non-parent"),
       col=cols2[c("CP","CNP","NCP","NCNP")],pch=15,xpd = TRUE,ncol=2,cex=1.25)


```




### Selection on courter and parent traits


Although selection is built into the model, if the population becomes
fixed for specific morphs -- and specific genotypes -- selection might
not be able to act due to a lack of variation. To investigate the
dynamics of selection over the course of each simulation (12,000
generations total), selection gradients on the courter trait and parent
trait (both the binary variable of courter/non-courter and
parent/non-parent) were estimated as the slope of a linear regression of
lifetime reproductive success on each trait value in generation 0 and in
generation 12,000. These patterns of selection were compared across
genetic architectures and parameter settings. Furthermore, we looked at
patterns of lifetime reproductive success across morphs within each
simulation in the final generation to evaluate whether balancing
selection contributed to morph diversity.

Specifically, we
estimated selection gradients for the courter and parental traits in the
first and last generations of the simulations. Selection consistently
favoured parent traits, whereas courter traits could experience negative
selection in high diversity parameter scenarios (Fig.
\@ref(fig:selectionGradients)). Selection was strong in the first
generation, but by generation 12000 selection was substantially relaxed
on one or the other trait, in most cases. A number of the low diversity
replicates resulted in highly correlated selection on courters and
parents, with a number of points falling on the positive 1:1 line (Fig.
\@ref(fig:selectionGradients)).


```{r seldat}
seldat<-readRDS("selection_gradients.RDS")
seldat<-seldat[grep("monogamy_nm",names(seldat))]
```
```{r selectionGradients, fig.height=4.5, fig.width=7, fig.cap="Selection gradients on parent and courter traits differ across the scenarios of our simulation model. In the first generation, selection always favours the parent trait, but selection gradients on the courter trait can be negative under parameter settings that favoured high diversity. By the end of the simulations (generation 12000), selection has been relaxed, so that selection on the parent trait is often near zero, as is selection on the courter trait. In some cases, the selection gradients on courter and parent traits are correlated at this final generation, especially in low diversity scenarios with QTLs as the genetic architecture. Solid grey lines show the x- and y-axes, with dotted grey lines showing the one-to-one correlation lines."}
par(mfrow=c(1,2))
plot(-0.25:0.25, -0.25:0.25, 
     type='n',
     xlim=c(-.25,0.25),
     ylim=c(-0.01,0.25),
     xlab="Initial generation",
     ylab="Selection gradient on parent trait",
     main="",
     bty='n', 
     axes=FALSE)
abline(v=0, col="grey")
abline(a=0,b=1,col="grey",lwd=2,lty=2)
abline(a=0,b=-1,col="grey",lwd=2,lty=2)
mtext("Selection gradient on courter trait", side=1,outer=TRUE, line=-3)
axis(1, col="grey",pos=0,col.axis="grey",at = seq(-0.25,0.25,by=0.25))
axis(2, col="grey", pos=-0.25,col.axis="grey",lwd=0,at = seq(0,0.25,by=0.125))

tmp<-lapply(seldat, function(dat){
  dat<-dat[dat[,"gen"]==0,]
  

  points(dat[,"court_cat_b1"],
         dat[,"parent_cat_b1"],
         pch=dat[,"supergene"]+16,
         col=scales::alpha(divcols[dat[,"highDiv"]+1],0.5),
           cex=1.5
  )
  arrows(
    x0 = dat[,"court_cat_b1"] - dat[,"court_cat_b1_se"],
    x1 = dat[,"court_cat_b1"] + dat[,"court_cat_b1_se"],
    y0 = dat[,"parent_cat_b1"],
    y1 = dat[,"parent_cat_b1"],
    code = 0,
    col=scales::alpha(divcols[dat[,"highDiv"]+1],0.5)
      )
    arrows(
    x0 = dat[,"court_cat_b1"] ,
    x1 = dat[,"court_cat_b1"] ,
    y0 = dat[,"parent_cat_b1"] - dat[,"parent_cat_b1_se"],
    y1 = dat[,"parent_cat_b1"] + dat[,"parent_cat_b1_se"],
    code = 0,
    col=scales::alpha(divcols[dat[,"highDiv"]+1],0.5)
      )

})

plot(-0.25:0.25, -0.25:0.25, 
     type='n',
     xlim=c(-.25,0.25),
     ylim=c(-0.01,0.25),
     xlab="Final Generation",
     ylab="",
     main="",
     bty='n', 
     axes=FALSE)
abline(v=0, col="grey")
abline(a=0,b=1,col="grey",lwd=2,lty=2)
abline(a=0,b=-1,col="grey",lwd=2,lty=2)
axis(1, col="grey",pos=0,col.axis="grey",at = seq(-0.25,0.25,by=0.25))
axis(2, col="grey", pos=-0.25,col.axis="grey",lwd=0,at = seq(0,0.25,by=0.125))

tmp<-lapply(seldat, function(dat){
  dat<-dat[dat[,"gen"]==12000,]
  if(nrow(dat)>0){
    
    
    points(dat[,"court_cat_b1"],
           dat[,"parent_cat_b1"],
           pch=dat[,"supergene"]+16,
           col=scales::alpha(divcols[dat[,"highDiv"]+1],0.5),
           cex=1.5
    )
    arrows(
      x0 = dat[,"court_cat_b1"] - dat[,"court_cat_b1_se"],
      x1 = dat[,"court_cat_b1"] + dat[,"court_cat_b1_se"],
      y0 = dat[,"parent_cat_b1"],
      y1 = dat[,"parent_cat_b1"],
      code = 0,
      col=scales::alpha(divcols[dat[,"highDiv"]+1],0.5)
        )
      arrows(
      x0 = dat[,"court_cat_b1"] ,
      x1 = dat[,"court_cat_b1"] ,
      y0 = dat[,"parent_cat_b1"] - dat[,"parent_cat_b1_se"],
      y1 = dat[,"parent_cat_b1"] + dat[,"parent_cat_b1_se"],
      code = 0,
      col=scales::alpha(divcols[dat[,"highDiv"]+1],0.5)
        )
  }
})
outer_legend("top",
       bty='n',
       pch=c(15, 16, 0,0),
       lty=c(0, 0, 1,1),
       lwd=c(2,2,1,1),
       col=c("grey", "grey",divcols[2],divcols[1]),
       legend=c("Supergenes", "QTLs", "High Diversity", "Low Diversity"),
       ncol=4)
```

We also compared lifetime reproductive success across male morphs to
determine whether balancing selection is the primary factor maintaining
variation. We found that in the high diversity parameter sets -- when
two morphs are maintained at high frequencies -- that the retained
morphs tend to have relatively equal lifetime reproductive success in
the final generation of the model (Fig. \@ref(fig:balacingSelection)).
In the low diversity parameter sets, if multiple morphs are found, the
others are at low frequency compared to the high frequency CP morph, and
have substantially lower lifetime reproductive success. These patterns
are indicative of balancing selection favouring the maintenance of two
or more morphs, even after selection has been relaxed on each trait
individually.

```{r balacingSelection, fig.cap="Plots of average lifetime reproductive success (and SEM) for each male morph in each replicate in the final generation of the simulations. The lines connect points from within a replicate. Point size reflects the frequency of that morph in the replicate. These graphs show that the high diversity scenarios generally maintain a stable polymorphism of two or more morphs at high frequency due to balancing selection (i.e., equivalent fitness of morphs). The low diversity scenarios occasionally have low frequencies of other morphs, but they tend to be the result of recombination and not balancing selection (i.e., their fitnesses are substantially lower than the high frequency CP morph)."}
knitr::include_graphics("../figs/fitnessPlots-1.png")
```

## Example haplotypes

### supergene


```{r supergeneExampleData, warning=FALSE}
# Looking into supergene haplotypes
vcfname<-"highDiversity_qtls_monogamy_nm_prop0.05_q8_c2_1_pop_0.vcf"
vcf1<-read.vcfR(vcfname)
qtl_dat<-read.delim(gsub("_pop_\\d\\.vcf","_qtlinfo.txt",vcfname))
qtl_dat<-qtl_dat[1,]
qtl_locs<-which(vcf1@fix[,"ID"] %in% qtl_dat)
qtls<-data.frame(chrom=gsub("(\\d)\\.(\\d+)","\\1",qtl_dat[!is.na(qtl_dat)][-1]),
                 qtl=gsub("(\\d)\\.(\\d+)","\\2",qtl_dat[!is.na(qtl_dat)][-1]),
                 trait=gsub("^(\\w).*$","\\1",colnames(qtl_dat[which(!is.na(qtl_dat))[-1]])))


qtls$col<-cols["courter"]
qtls$col[qtls$trait=="P"]<-cols["parent"]

qtls$loc<-as.numeric(qtls$chrom)*1000 + as.numeric(qtls$qtl)

# taj d
td<-read.delim(gsub("vcf","Tajima\\.D",vcfname))
td$QTL<-FALSE
for(chrom in unique(td$CHROM)){
  chtd<-td[td$CHROM==chrom,]
  
  locs<-qtls[qtls$chrom ==chrom,"qtl"]
  for(i in 1:nrow(chtd)){
    for(loc in locs){
      loc<-as.numeric(loc)
      if(loc >= chtd[i,"BIN_START"] & loc <= chtd[i,"BIN_START"]+chtd[i,"N_SNPS"]){
        # then there's a qtl there
        chtd$QTL[i] <- TRUE
      }
    }
  }
  # Save it back to the overall df
  td[td$CHROM==chrom,"QTL"]<-chtd$QTL
}

# pops for Gst
mf_pop<-as.factor(gsub("^(\\w{3}).*$","\\1",colnames(vcf1@gt)[-1]))
mt_pop<-as.factor(gsub("^(\\w{3}).*_(\\w+)$","\\2",colnames(vcf1@gt)[-1]))
mt_mal<-factor(mt_pop[mf_pop=="MAL"])
mf_diff<-genetic_diff(vcf1, pops = mf_pop, method = 'nei')
mal_vcf<-vcf1[,c(1,which(mf_pop=="MAL")+1)]
mtm_diff<-genetic_diff(mal_vcf, pops = mt_mal, method = 'nei')

# files for GWAS
genofile <- gsub("\\.vcf","_gt.csv",vcfname)
trait_name<-gsub("_pop_\\d+\\.vcf","_traits\\.txt",vcfname)
pop<-as.numeric(gsub("^.*pop_(\\d+).*$","\\1",vcfname))
phenofile <- gsub("traits\\.txt",paste0("pop",pop,"_pheno.csv"),trait_name)


```

```{r supergeneGenos}
vcf_cp<- vcf1[vcf1@fix[,"CHROM"] %in% qtls$chrom & vcf1@fix[,"POS"] %in% qtls$qtl, grep("_CP",colnames(vcf1@gt))]
cp_gts<-vcf_cp@gt
cp_gts[cp_gts=="0/0"]<-"0"
cp_gts[cp_gts=="1/0"]<-"1"
cp_gts[cp_gts=="0/1"]<-"1"
cp_gts[cp_gts=="1/1"]<-"2"
cp_num<-matrix(as.numeric(cp_gts),    # Convert to numeric matrix
                  ncol = ncol(cp_gts))

vcf_p<- vcf1[vcf1@fix[,"CHROM"] %in% qtls$chrom & vcf1@fix[,"POS"] %in% qtls$qtl, grep("_P",colnames(vcf1@gt))]
p_gts<-vcf_p@gt
p_gts[p_gts=="0/0"]<-"0"
p_gts[p_gts=="1/0"]<-"1"
p_gts[p_gts=="0/1"]<-"1"
p_gts[p_gts=="1/1"]<-"2"
p_num<-matrix(as.numeric(p_gts),    # Convert to numeric matrix
                  ncol = ncol(p_gts))

```


```{r supergeneGenotypes}
# QTL genotypes
tmp<-cbind(p_num,
            rep(NA,nrow(qtls)),
            cp_num)
image(tmp,
      col=gt_cols,
      axes=FALSE,
      #ylab="Courter/Parents",
      cex.lab=2)
abline(h=(ncol(p_num)+1)/ncol(tmp),lwd=2)
axis(1,at=seq(0,1,length.out=nrow(qtls)),
     labels = qtls$trait,lwd=0)

mtext("CP",2,line=2,adj =0.9,cex=0.75)

mtext("NP",2,line=2,adj =0.2,cex=0.75)

```

### QTLs



```{r qtlExampleData, warning=FALSE, message=FALSE}
# Looking into supergene haplotypes
vcfname<-"highDiversity_qtls_monogamy_nm_q8_c2_1_pop_0.vcf"
vcf1<-read.vcfR(vcfname)
qtl_dat<-read.delim(gsub("_pop_\\d\\.vcf","_qtlinfo.txt",vcfname))
qtl_dat<-qtl_dat[1,]
qtl_locs<-which(vcf1@fix[,"ID"] %in% qtl_dat)
qtls<-data.frame(chrom=gsub("(\\d)\\.(\\d+)","\\1",qtl_dat[!is.na(qtl_dat)][-1]),
                 qtl=gsub("(\\d)\\.(\\d+)","\\2",qtl_dat[!is.na(qtl_dat)][-1]),
                 trait=gsub("^(\\w).*$","\\1",colnames(qtl_dat[which(!is.na(qtl_dat))[-1]])))

qtls$col<-cols["courter"]
qtls$col[qtls$trait=="P"]<-cols["parent"]

qtls$loc<-as.numeric(qtls$chrom)*1000 + as.numeric(qtls$qtl)

# taj d
td<-read.delim(gsub("vcf","Tajima\\.D",vcfname))
td$QTL<-FALSE
for(chrom in unique(td$CHROM)){
  chtd<-td[td$CHROM==chrom,]
  
  locs<-qtls[qtls$chrom ==chrom,"qtl"]
  for(i in 1:nrow(chtd)){
    for(loc in locs){
      loc<-as.numeric(loc)
      if(loc >= chtd[i,"BIN_START"] & loc <= chtd[i,"BIN_START"]+chtd[i,"N_SNPS"]){
        # then there's a qtl there
        chtd$QTL[i] <- TRUE
      }
    }
  }
  # Save it back to the overall df
  td[td$CHROM==chrom,"QTL"]<-chtd$QTL
}

# pops for Gst
mf_pop<-as.factor(gsub("^(\\w{3}).*$","\\1",colnames(vcf1@gt)[-1]))
mt_pop<-as.factor(gsub("^(\\w{3}).*_(\\w+)$","\\2",colnames(vcf1@gt)[-1]))
mt_mal<-factor(mt_pop[mf_pop=="MAL"])
mf_diff<-genetic_diff(vcf1, pops = mf_pop, method = 'nei')
mal_vcf<-vcf1[,c(1,which(mf_pop=="MAL")+1)]
mtm_diff<-genetic_diff(mal_vcf, pops = mt_mal, method = 'nei')

# files for GWAS
genofile <- gsub("\\.vcf","_gt.csv",vcfname)
trait_name<-gsub("_pop_\\d+\\.vcf","_traits\\.txt",vcfname)
pop<-as.numeric(gsub("^.*pop_(\\d+).*$","\\1",vcfname))
phenofile <- gsub("traits\\.txt",paste0("pop",pop,"_pheno.csv"),trait_name)


```


```{r qtlGenos}
vcf_cp<- vcf1[vcf1@fix[,"CHROM"] %in% qtls$chrom & vcf1@fix[,"POS"] %in% qtls$qtl, grep("_CP",colnames(vcf1@gt))]
cp_gts<-vcf_cp@gt
cp_gts[cp_gts=="0/0"]<-"0"
cp_gts[cp_gts=="1/0"]<-"1"
cp_gts[cp_gts=="0/1"]<-"1"
cp_gts[cp_gts=="1/1"]<-"2"
cp_num<-matrix(as.numeric(cp_gts),    # Convert to numeric matrix
                  ncol = ncol(cp_gts))

vcf_p<- vcf1[vcf1@fix[,"CHROM"] %in% qtls$chrom & vcf1@fix[,"POS"] %in% qtls$qtl, grep("_P",colnames(vcf1@gt))]
p_gts<-vcf_p@gt
p_gts[p_gts=="0/0"]<-"0"
p_gts[p_gts=="1/0"]<-"1"
p_gts[p_gts=="0/1"]<-"1"
p_gts[p_gts=="1/1"]<-"2"
p_num<-matrix(as.numeric(p_gts),    # Convert to numeric matrix
                  ncol = ncol(p_gts))

```


```{r qtlGenotypes}
# QTL genotypes
tmp<-cbind(p_num,
            rep(NA,nrow(qtls)),
            cp_num)
image(tmp,
      col=gt_cols,
      axes=FALSE,
      #ylab="Courter/Parents",
      cex.lab=2)
abline(h=(ncol(p_num)+1)/ncol(tmp),lwd=2)
axis(1,at=seq(0,1,length.out=nrow(qtls)),
     labels = qtls$trait,lwd=0)

mtext("CP",2,line=2,adj =0.9,cex=0.75)

mtext("NP",2,line=2,adj =0.2,cex=0.75)



```

## Example genome-wide

```{r ExampleGenomewide,out.width="49%", fig.cap="True QTLs for the courter (blue) and parent (green) traits are not outliers int he distributions of population genetic statistics. Plots of genome-wide estimates of population genetic parameters from representative simulations using QTLs (left) versus supergenes (right), both with 8 QTLs per trait and 2 chromosomes (light vs dark grey points) with 1000 marker loci each. The plots show genome-wide estimates of commonly-estimated population genetic parameters. From top to bottom: p-values from a genome-wide association test for the courter trait; p-values from a genome-wide association test for the parent trait; Gst between male morphs; smoothed Tajima's D estimated in 10bp segments; expected heterozygosity; and average pairwise linkage disequilibrium.",fig.show='hold',fig.align='center', fig.keep=TRUE}
knitr::include_graphics(c("../figs/QTLFig-1.png","../figs/supergeneFig-1.png"))
```

## Distributions of significance of genome-wide summary statistics

```{r}
welch_correctDF<-function(var1,var2,n1,n2){
  num<-((var1/n1)+(var2/n2))^2
  den<-(((var1/n1)^2)/(n1-1))+(((var2/n2)^2)/(n2-1))
  df<-num/den
  return(df)
}

```

```{r readGenomewide}

qtl_outliers<-read.csv("qtl_outliers.csv")
qtl_outliers$Architecture<-"qtls"
supergene_outliers<-read.csv("supergene_outliers.csv")
supergene_outliers$Architecture<-"supergene"
popgen_data<-dplyr::bind_rows(qtl_outliers,supergene_outliers)

# add low diversity ones
qtl_outliers<-read.csv("qtl_outliers_lowDiv.csv")
qtl_outliers$Architecture<-"qtls"
popgen_data<-dplyr::bind_rows(popgen_data,qtl_outliers)
supergene_outliers<-read.csv("supergene_outliers_lowDiv.csv")
supergene_outliers$Architecture<-"supergene"
popgen_data<-dplyr::bind_rows(popgen_data,supergene_outliers)

sediff<-sqrt((popgen_data$gHtVar/(popgen_data$nChrom*1000)) + 
               (popgen_data$qHtVar/(popgen_data$nQTLS)))
HetT<-(popgen_data$gHtMean - popgen_data$qHtMean)/sediff
HetP<-pt(HetT,
         df = welch_correctDF(popgen_data$gHtVar,
                              popgen_data$qHtVar,
                              (popgen_data$nChrom*1000),
                              popgen_data$nQTLS), 
         lower.tail = (HetT >=0))

popgen_data$HetP<-HetP
popgen_data$Diversity<-factor(gsub("^.*/(\\w+)Diversity.*$","\\1",popgen_data$sim),
                              levels=c("low","high"))



final_freqs<-read.csv("../results/morph_freqs_summary.csv")
final_freqs$rep  <-gsub("../fixedART-results/.*\\/(.*\\w+_monogamy_nm_.*pop\\d).*","\\1",final_freqs$file)

td_summary<-read.csv("../results/tajimaD_summary.csv", row.names = 1)
td_summary<-td_summary[grep("monogamy_nm",rownames(td_summary)),]
td_summary$rep<-gsub("../fixedART-results/.*\\/(.*\\w+_monogamy_nm_.*pop)_(\\d).*","\\1\\2",rownames(td_summary))

td_summary$architecture<-gsub("../fixedART-results/(.*)\\/\\/(\\w+)Diversity_.*_monogamy_nm_.*pop_(\\d).*","\\1",rownames(td_summary))
td_summary$diversity<-factor(gsub("../fixedART-results/(.*)\\/\\/(\\w+)Diversity_.*_monogamy_nm_.*pop_(\\d).*","\\2",rownames(td_summary)),
                           levels=c("low","high"))


td_freqs<-merge(td_summary, final_freqs,by="rep")



```

```{r genomewideDiv, fig.cap="Tests for statistical significance of differences in genome-wide genetic diversity in the final generation of the simulations between different genetic architectures. Shown are p-values for t-tests comparing genome-wide observed heterozygosity (A) and Tajima’s D (B) between runs with genome-wide QTLs versus supergenes.", fig.keep='last'}

par(mfrow=c(1,2),xpd=TRUE, mar=c(5,5,1.5,1), oma=c(0,0,5,1))

plot(popgen_data$propCP,
     popgen_data$HetP,
     pch=as.numeric(as.factor(popgen_data$Architecture))+15,
     col=scales::alpha(
       divcols[as.numeric(popgen_data[,"Diversity"])],
       0.5),
     cex=2,
     cex.lab=2,
     cex.axis=2,
     xlab="",
     ylab="Obs. Het. P-value",
     bty='l')
legend("topleft","A",cex=2.5, bty='n', x.intersp = -0.9)


# Tajima's D
plot(td_freqs$CP,
     td_freqs$p,
     pch=as.numeric(as.factor(td_freqs$architecture))+15,
     col=scales::alpha(
       divcols[as.numeric(td_freqs$diversity)],
       0.5),
     cex=2,
     cex.lab=2,
     cex.axis=2,
     xlab="",
     ylab="Tajima's D P-value",
     bty='l')
legend("topleft","B",cex=2.5, bty='n', x.intersp = -0.9)



mtext("Courter-Parent Frequency", 1, outer=TRUE, line=-1, cex=1.5)

outer_legend("top",
       bty='n',
       pch=c(17, 16, 15,15),
       lty=c(0, 0, 1,1),
       col=c("grey", "grey",divcols["high"],divcols["low"]),
       legend=c("Supergenes", "QTLs", "High Diversity", "Low Diversity"),
       ncol=4,
       cex=2.5,
       pt.cex=2)

```

```{r GstProportions, fig.cap="The proportion of QTLs whose p-value was elevated in the comparison of male-male allele frequencies. If a male-male Gst comparison accurately detects causal QTLs, the majority of QTLs should be in regions of the genome with elevated p-values. Instead, we observed a low proportion of true QTLs being detected in p-value peaks."}
# Gst
plot(popgen_data$propCP,
     popgen_data$propQTLsInPeaksMM,
     pch=as.numeric(as.factor(popgen_data$Architecture))+15,
     col=scales::alpha(
       divcols[as.numeric(popgen_data[,"Diversity"])],
       0.5),
     cex=1.5,
     cex.lab=1.5,
     xlab="Courter/Parent Frequency",
     ylab="Prop. QTL in Gst peak",
     bty='l')

outer_legend("top",
       bty='n',
       pch=c(17, 16, 15,15),
       lty=c(0, 0, 1,1),
       col=c("grey", "grey",divcols["high"],divcols["low"]),
       legend=c("Supergenes", "QTLs", "High Diversity", "Low Diversity"),
       ncol=4,
       cex=2.5,
       pt.cex=2)

```

